{"version":3,"sources":["../src/orm-detectors/base-detector.ts","../src/orm-detectors/prisma-detector.ts","../src/orm-detectors/drizzle-detector.ts","../src/orm-detectors/typeorm-detector.ts","../src/database/connection.ts","../src/database/analysis.ts","../src/database/adapters.ts"],"sourcesContent":["/**\n * Base ORM detector with common functionality\n */\n\nimport { join } from 'path'\nimport { ORMDetector, ORMConfig } from '@driftjs/core'\nimport { DatabaseConfig, DetectionResult, FilePath } from '@driftjs/core'\nimport { exists, createFilePath, readJsonFile, findFiles } from '@driftjs/core'\n\nexport abstract class BaseORMDetector implements ORMDetector {\n  abstract name: string\n  \n  /**\n   * Detect if this ORM is present in the project\n   */\n  abstract detect(projectPath: string): Promise<DetectionResult>\n  \n  /**\n   * Extract ORM-specific configuration\n   */\n  abstract extractConfig(projectPath: string): Promise<ORMConfig | null>\n  \n  /**\n   * Extract database configuration from ORM setup\n   */\n  abstract getDatabaseConfig(projectPath: string): Promise<DatabaseConfig | null>\n  \n  /**\n   * Common helper: Check if package.json contains specific dependencies\n   */\n  protected async checkPackageJsonDependencies(\n    projectPath: string,\n    dependencies: string[]\n  ): Promise<{ found: string[]; missing: string[] }> {\n    const packageJsonPath = join(projectPath, 'package.json')\n    const packageResult = await readJsonFile<{ dependencies?: Record<string, string>; devDependencies?: Record<string, string> }>(packageJsonPath)\n    \n    if (!packageResult.success) {\n      return { found: [], missing: dependencies }\n    }\n    \n    const allDeps = {\n      ...packageResult.data.dependencies,\n      ...packageResult.data.devDependencies\n    }\n    \n    const found = dependencies.filter(dep => dep in allDeps)\n    const missing = dependencies.filter(dep => !(dep in allDeps))\n    \n    return { found, missing }\n  }\n  \n  /**\n   * Common helper: Check if specific files exist\n   */\n  protected async checkFiles(\n    projectPath: string,\n    filePaths: string[]\n  ): Promise<{ existing: FilePath[]; missing: string[] }> {\n    const existing: FilePath[] = []\n    const missing: string[] = []\n    \n    for (const filePath of filePaths) {\n      const fullPath = join(projectPath, filePath)\n      const fileExists = await exists(fullPath)\n      \n      if (fileExists) {\n        existing.push(await createFilePath(filePath, projectPath))\n      } else {\n        missing.push(filePath)\n      }\n    }\n    \n    return { existing, missing }\n  }\n  \n  /**\n   * Common helper: Find files matching patterns\n   */\n  protected async findFilesByPattern(\n    projectPath: string,\n    patterns: RegExp[],\n    directories: string[] = ['.']\n  ): Promise<string[]> {\n    const allFiles: string[] = []\n    \n    for (const directory of directories) {\n      const fullDirectory = join(projectPath, directory)\n      \n      for (const pattern of patterns) {\n        const files = await findFiles(fullDirectory, pattern, true)\n        allFiles.push(...files)\n      }\n    }\n    \n    return allFiles\n  }\n  \n  /**\n   * Common helper: Calculate confidence score based on evidence\n   */\n  protected calculateConfidence(evidence: {\n    required: { found: number; total: number }\n    optional: { found: number; total: number }\n    negative: number\n  }): number {\n    if (evidence.required.total === 0) {\n      return 0\n    }\n    \n    const requiredScore = evidence.required.found / evidence.required.total\n    const optionalScore = evidence.optional.total > 0 \n      ? evidence.optional.found / evidence.optional.total \n      : 0\n    \n    // Base score from required items (70% weight)\n    const baseScore = requiredScore * 0.7\n    \n    // Bonus from optional items (30% weight)\n    const bonusScore = optionalScore * 0.3\n    \n    // Penalty for negative evidence\n    const penalty = Math.min(evidence.negative * 0.1, 0.5)\n    \n    return Math.max(0, Math.min(1, baseScore + bonusScore - penalty))\n  }\n  \n  /**\n   * Parse database URL into DatabaseConfig\n   */\n  protected parseDatabaseUrl(url: string): DatabaseConfig | null {\n    try {\n      const parsed = new URL(url)\n      \n      let type: DatabaseConfig['type']\n      \n      switch (parsed.protocol) {\n        case 'postgresql:':\n        case 'postgres:':\n          type = 'postgresql'\n          break\n        case 'mysql:':\n          type = 'mysql'\n          break\n        case 'sqlite:':\n          type = 'sqlite'\n          break\n        default:\n          return null\n      }\n      \n      return {\n        type,\n        host: parsed.hostname || undefined,\n        port: parsed.port ? parseInt(parsed.port) : undefined,\n        database: parsed.pathname.slice(1), // Remove leading slash\n        username: parsed.username || undefined,\n        password: parsed.password || undefined,\n        url\n      }\n    } catch {\n      return null\n    }\n  }\n} ","/**\n * Prisma ORM detector implementation\n */\n\nimport { join } from 'path'\nimport { BaseORMDetector } from './base-detector.js'\nimport { PrismaConfig } from '@driftjs/core'\nimport { DatabaseConfig, DetectionResult } from '@driftjs/core'\nimport { readFileContent, createFilePath } from '@driftjs/core'\n\nexport class PrismaDetector extends BaseORMDetector {\n  name = 'prisma'\n  \n  /**\n   * Detect Prisma in the project\n   */\n  async detect(projectPath: string): Promise<DetectionResult> {\n    const evidence: string[] = []\n    const warnings: string[] = []\n    \n    // Check for Prisma dependencies\n    const { found: foundDeps, missing: missingDeps } = await this.checkPackageJsonDependencies(\n      projectPath,\n      ['prisma', '@prisma/client']\n    )\n    \n    evidence.push(...foundDeps.map(dep => `Found dependency: ${dep}`))\n    \n    // Check for Prisma schema file\n    const { existing: schemaFiles } = await this.checkFiles(projectPath, [\n      'prisma/schema.prisma',\n      'schema.prisma'\n    ])\n    \n    if (schemaFiles.length > 0) {\n      evidence.push(`Found schema file: ${schemaFiles[0].relative}`)\n    }\n    \n    // Check for migration directory\n    const { existing: migrationDirs } = await this.checkFiles(projectPath, [\n      'prisma/migrations'\n    ])\n    \n    if (migrationDirs.length > 0) {\n      evidence.push(`Found migrations directory: ${migrationDirs[0].relative}`)\n    }\n    \n    // Look for generated Prisma client\n    const generatedFiles = await this.findFilesByPattern(\n      projectPath,\n      [/node_modules\\/@prisma\\/client/],\n      ['node_modules']\n    )\n    \n    if (generatedFiles.length > 0) {\n      evidence.push('Found generated Prisma client')\n    }\n    \n    // Calculate confidence\n    const confidence = this.calculateConfidence({\n      required: { found: foundDeps.length, total: 2 }, // prisma + @prisma/client\n      optional: { found: schemaFiles.length + migrationDirs.length, total: 2 },\n      negative: 0\n    })\n    \n    // Add warnings for incomplete setup\n    if (foundDeps.length > 0 && schemaFiles.length === 0) {\n      warnings.push('Prisma dependency found but no schema.prisma file detected')\n    }\n    \n    if (schemaFiles.length > 0 && !foundDeps.includes('@prisma/client')) {\n      warnings.push('Schema file found but @prisma/client not installed')\n    }\n    \n    return {\n      found: confidence > 0.5,\n      confidence,\n      evidence,\n      warnings: warnings.length > 0 ? warnings : undefined\n    }\n  }\n  \n  /**\n   * Extract Prisma configuration\n   */\n  async extractConfig(projectPath: string): Promise<PrismaConfig | null> {\n    // Find schema file\n    const { existing: schemaFiles } = await this.checkFiles(projectPath, [\n      'prisma/schema.prisma',\n      'schema.prisma'\n    ])\n    \n    if (schemaFiles.length === 0) {\n      return null\n    }\n    \n    const schemaFile = schemaFiles[0]\n    const migrationDirectory = await createFilePath('prisma/migrations', projectPath)\n    \n    // Parse schema file for generator and database info\n    const schemaResult = await readFileContent(schemaFile.absolute)\n    if (!schemaResult.success) {\n      return null\n    }\n    \n    // Extract client generator config\n    let clientGenerator: PrismaConfig['clientGenerator']\n    const generatorMatch = schemaResult.data.match(/generator\\s+client\\s*{([^}]+)}/s)\n    if (generatorMatch) {\n      const generatorConfig = generatorMatch[1]\n      const providerMatch = generatorConfig.match(/provider\\s*=\\s*\"([^\"]+)\"/)\n      const outputMatch = generatorConfig.match(/output\\s*=\\s*\"([^\"]+)\"/)\n      \n      clientGenerator = {\n        provider: providerMatch?.[1] || 'prisma-client-js',\n        output: outputMatch?.[1]\n      }\n    }\n    \n    return {\n      type: 'prisma',\n      configFile: schemaFile,\n      migrationDirectory,\n      schemaFile,\n      dependencies: ['prisma', '@prisma/client'],\n      clientGenerator\n    }\n  }\n  \n  /**\n   * Extract database configuration from Prisma schema\n   */\n  async getDatabaseConfig(projectPath: string): Promise<DatabaseConfig | null> {\n    const config = await this.extractConfig(projectPath)\n    if (!config) {\n      return null\n    }\n    \n    // Read schema file\n    const schemaResult = await readFileContent(config.schemaFile.absolute)\n    if (!schemaResult.success) {\n      return null\n    }\n    \n    // Parse datasource block\n    const datasourceMatch = schemaResult.data.match(/datasource\\s+\\w+\\s*{([^}]+)}/s)\n    if (!datasourceMatch) {\n      return null\n    }\n    \n    const datasourceConfig = datasourceMatch[1]\n    \n    // Extract provider\n    const providerMatch = datasourceConfig.match(/provider\\s*=\\s*\"([^\"]+)\"/)\n    const provider = providerMatch?.[1]\n    \n    // Extract URL\n    const urlMatch = datasourceConfig.match(/url\\s*=\\s*env\\(\"([^\"]+)\"\\)/) ||\n                    datasourceConfig.match(/url\\s*=\\s*\"([^\"]+)\"/)\n    \n    if (!urlMatch) {\n      return null\n    }\n    \n    let databaseUrl: string\n    if (urlMatch[0].includes('env(')) {\n      // Environment variable reference\n      const envVar = urlMatch[1]\n      databaseUrl = process.env[envVar] || ''\n      \n      if (!databaseUrl) {\n        // Return basic config with type only\n        return {\n          type: this.mapPrismaProviderToType(provider),\n          database: 'unknown'\n        }\n      }\n    } else {\n      // Direct URL\n      databaseUrl = urlMatch[1]\n    }\n    \n    // Parse the database URL\n    const dbConfig = this.parseDatabaseUrl(databaseUrl)\n    if (dbConfig) {\n      return dbConfig\n    }\n    \n    // Fallback to provider-based detection\n    return {\n      type: this.mapPrismaProviderToType(provider),\n      database: 'unknown'\n    }\n  }\n  \n  /**\n   * Map Prisma provider to database type\n   */\n  private mapPrismaProviderToType(provider?: string): DatabaseConfig['type'] {\n    switch (provider) {\n      case 'postgresql':\n        return 'postgresql'\n      case 'mysql':\n        return 'mysql'\n      case 'sqlite':\n        return 'sqlite'\n      default:\n        return 'postgresql' // Default assumption\n    }\n  }\n} ","/**\n * Drizzle ORM detector implementation\n * Detects Drizzle projects by looking for drizzle.config.ts/js files and schema patterns\n */\n\nimport { BaseORMDetector } from './base-detector.js'\nimport { DrizzleConfig } from '@driftjs/core'\nimport { DatabaseConfig, DetectionResult } from '@driftjs/core'\nimport path from 'path'\nimport fs from 'fs/promises'\n\nexport class DrizzleDetector extends BaseORMDetector {\n  name = 'drizzle'\n  \n  async detect(projectPath: string): Promise<DetectionResult> {\n    const evidence: string[] = []\n    \n    try {\n      // Check for drizzle.config.ts/js files\n      const configFiles = [\n        'drizzle.config.ts',\n        'drizzle.config.js',\n        'drizzle.config.mjs'\n      ]\n      \n             const { existing: configFilesFound } = await this.checkFiles(projectPath, configFiles)\n       evidence.push(...configFilesFound.map(f => `Found config file: ${f.relative}`))\n       \n       // Check for package.json with drizzle dependencies\n       const deps = await this.checkPackageJsonDependencies(projectPath, ['drizzle-orm', 'drizzle-kit'])\n       evidence.push(...deps.found.map(dep => `Found dependency: ${dep}`))\n       \n       // Check for common schema file patterns\n       const schemaPatterns = [\n         'src/db/schema.ts',\n         'src/schema.ts',\n         'db/schema.ts',\n         'schema.ts',\n         'src/lib/db/schema.ts'\n       ]\n       \n       const { existing: schemaFiles } = await this.checkFiles(projectPath, schemaPatterns)\n       evidence.push(...schemaFiles.map(f => `Found schema file: ${f.relative}`))\n       \n       // Check for migrations directory\n       const migrationDirs = ['drizzle', 'migrations', 'drizzle/migrations']\n       const { existing: migrationDirsFound } = await this.checkFiles(projectPath, migrationDirs)\n       evidence.push(...migrationDirsFound.map(f => `Found migration directory: ${f.relative}`))\n      \n      // Calculate confidence using helper\n      const confidence = this.calculateConfidence({\n        required: { \n          found: deps.found.length > 0 ? 1 : 0, \n          total: 1 \n        },\n        optional: { \n          found: configFilesFound.length + schemaFiles.length + migrationDirsFound.length, \n          total: configFiles.length + schemaPatterns.length + migrationDirs.length \n        },\n        negative: 0\n      })\n      \n      return {\n        found: confidence > 0.3,\n        confidence: Math.round(confidence * 100),\n        evidence\n      }\n    } catch (error) {\n      return {\n        found: false,\n        confidence: 0,\n        evidence: [`Error detecting Drizzle: ${error}`]\n      }\n    }\n  }\n  \n  async extractConfig(projectPath: string): Promise<DrizzleConfig | null> {\n    try {\n      // Try to find drizzle config file\n      const configFiles = [\n        'drizzle.config.ts',\n        'drizzle.config.js',\n        'drizzle.config.mjs'\n      ]\n      \n      const { existing: configFilesFound } = await this.checkFiles(projectPath, configFiles)\n      if (configFilesFound.length === 0) {\n        return null\n      }\n      \n      const configFile = configFilesFound[0]\n      const configContent = await fs.readFile(configFile.absolute, 'utf-8')\n      \n      // Basic config parsing - in production, we'd use a proper TS/JS parser\n      const driver = this.extractConfigValue(configContent, 'driver') || 'pg'\n      const validDrivers = ['pg', 'mysql2', 'better-sqlite3'] as const\n      const mappedDriver = validDrivers.includes(driver as any) ? driver as typeof validDrivers[number] : 'pg'\n      \n      const config: DrizzleConfig = {\n        type: 'drizzle',\n        configFile,\n        driver: mappedDriver,\n        schemaPath: this.extractConfigValue(configContent, 'schema') || './src/db/schema.ts',\n        outDir: this.extractConfigValue(configContent, 'out') || './drizzle',\n        migrationDirectory: configFile, // Will be updated with proper migration directory\n        dependencies: ['drizzle-orm', 'drizzle-kit']\n      }\n      \n      return config\n    } catch (error) {\n      console.warn(`Failed to extract Drizzle config: ${error}`)\n      return null\n    }\n  }\n  \n  async getDatabaseConfig(projectPath: string): Promise<DatabaseConfig | null> {\n    try {\n      // Look for database URL in various places\n      const envFiles = ['.env', '.env.local', '.env.development']\n      const { existing: envFilesFound } = await this.checkFiles(projectPath, envFiles)\n      \n      for (const envFile of envFilesFound) {\n        const envContent = await fs.readFile(envFile.absolute, 'utf-8')\n        const dbUrl = this.extractEnvValue(envContent, 'DATABASE_URL')\n        if (dbUrl) {\n          const parsed = this.parseDatabaseUrl(dbUrl)\n          if (parsed) return parsed\n        }\n      }\n      \n      // Fallback: try to extract from drizzle config\n      const drizzleConfig = await this.extractConfig(projectPath)\n      if (!drizzleConfig) return null\n      \n      // Map Drizzle driver to database type\n      const driverMap: Record<string, 'postgresql' | 'mysql' | 'sqlite'> = {\n        'pg': 'postgresql',\n        'mysql2': 'mysql',\n        'better-sqlite3': 'sqlite'\n      }\n      \n      const dbType = driverMap[drizzleConfig.driver] || 'postgresql'\n      \n      return {\n        type: dbType,\n        host: 'localhost',\n        port: dbType === 'postgresql' ? 5432 : dbType === 'mysql' ? 3306 : undefined,\n        database: 'main'\n      }\n    } catch (error) {\n      console.warn(`Failed to extract database config: ${error}`)\n      return null\n    }\n  }\n  \n  private extractConfigValue(content: string, key: string): string | undefined {\n    // Simple regex-based extraction - in production, use proper AST parsing\n    const regex = new RegExp(`${key}:\\\\s*['\"]([^'\"]+)['\"]`)\n    const match = content.match(regex)\n    return match?.[1]\n  }\n  \n  private extractEnvValue(content: string, key: string): string | undefined {\n    const regex = new RegExp(`^${key}\\\\s*=\\\\s*(.+)$`, 'm')\n    const match = content.match(regex)\n    return match?.[1]?.replace(/['\"]/g, '').trim()\n  }\n} ","/**\n * TypeORM detector implementation\n * Detects TypeORM projects by looking for ormconfig files, entity patterns, and migrations\n */\n\nimport { BaseORMDetector } from './base-detector.js'\nimport { TypeORMConfig } from '@driftjs/core'\nimport { DatabaseConfig, DetectionResult } from '@driftjs/core'\nimport path from 'path'\nimport fs from 'fs/promises'\n\nexport class TypeORMDetector extends BaseORMDetector {\n  name = 'typeorm'\n  \n  async detect(projectPath: string): Promise<DetectionResult> {\n    const evidence: string[] = []\n    \n    try {\n      // Check for TypeORM config files\n      const configFiles = [\n        'ormconfig.ts',\n        'ormconfig.js',\n        'ormconfig.json',\n        'typeorm.config.ts',\n        'typeorm.config.js',\n        'src/data-source.ts',\n        'src/data-source.js'\n      ]\n      \n      const { existing: configFilesFound } = await this.checkFiles(projectPath, configFiles)\n      evidence.push(...configFilesFound.map(f => `Found config file: ${f.relative}`))\n      \n      // Check for package.json with TypeORM dependencies\n      const deps = await this.checkPackageJsonDependencies(projectPath, ['typeorm', '@nestjs/typeorm'])\n      evidence.push(...deps.found.map(dep => `Found dependency: ${dep}`))\n      \n      // Check for common entity file patterns\n      const entityPatterns = await this.findFilesByPattern(\n        projectPath,\n        [/\\.entity\\.(ts|js)$/, /@Entity\\(/],\n        ['src', 'entities', 'entity']\n      )\n      if (entityPatterns.length > 0) {\n        evidence.push(`Found ${entityPatterns.length} entity files`)\n      }\n      \n      // Check for migrations directory\n      const migrationDirs = ['src/migrations', 'migrations', 'database/migrations']\n      const { existing: migrationDirsFound } = await this.checkFiles(projectPath, migrationDirs)\n      evidence.push(...migrationDirsFound.map(f => `Found migration directory: ${f.relative}`))\n      \n      // Check for migration files\n      const migrationPatterns = await this.findFilesByPattern(\n        projectPath,\n        [/\\d+.*\\.(ts|js)$/],\n        ['src/migrations', 'migrations', 'database/migrations']\n      )\n      if (migrationPatterns.length > 0) {\n        evidence.push(`Found ${migrationPatterns.length} migration files`)\n      }\n      \n      // Calculate confidence using helper\n      const confidence = this.calculateConfidence({\n        required: { \n          found: deps.found.length > 0 ? 1 : 0, \n          total: 1 \n        },\n        optional: { \n          found: configFilesFound.length + (entityPatterns.length > 0 ? 1 : 0) + migrationDirsFound.length + (migrationPatterns.length > 0 ? 1 : 0), \n          total: 4 \n        },\n        negative: 0\n      })\n      \n      return {\n        found: confidence > 0.3,\n        confidence: Math.round(confidence * 100),\n        evidence\n      }\n    } catch (error) {\n      return {\n        found: false,\n        confidence: 0,\n        evidence: [`Error detecting TypeORM: ${error}`]\n      }\n    }\n  }\n  \n  async extractConfig(projectPath: string): Promise<TypeORMConfig | null> {\n    try {\n      // Try to find TypeORM config file\n      const configFiles = [\n        'ormconfig.ts',\n        'ormconfig.js',\n        'ormconfig.json',\n        'typeorm.config.ts',\n        'typeorm.config.js',\n        'src/data-source.ts',\n        'src/data-source.js'\n      ]\n      \n      const { existing: configFilesFound } = await this.checkFiles(projectPath, configFiles)\n      if (configFilesFound.length === 0) {\n        return null\n      }\n      \n      const configFile = configFilesFound[0]\n      let entities: string[] = []\n      let migrations: string[] = []\n      \n      if (configFile.relative.endsWith('.json')) {\n        // Parse JSON config\n        const configContent = await fs.readFile(configFile.absolute, 'utf-8')\n        const jsonConfig = JSON.parse(configContent)\n        entities = Array.isArray(jsonConfig.entities) ? jsonConfig.entities : ['src/**/*.entity.{ts,js}']\n        migrations = Array.isArray(jsonConfig.migrations) ? jsonConfig.migrations : ['src/migrations/*.{ts,js}']\n      } else {\n        // Parse TypeScript/JavaScript config (basic parsing)\n        const configContent = await fs.readFile(configFile.absolute, 'utf-8')\n        entities = this.extractArrayValue(configContent, 'entities') || ['src/**/*.entity.{ts,js}']\n        migrations = this.extractArrayValue(configContent, 'migrations') || ['src/migrations/*.{ts,js}']\n      }\n      \n      const config: TypeORMConfig = {\n        type: 'typeorm',\n        configFile,\n        entities,\n        migrations,\n        migrationDirectory: configFile, // Will be updated with proper migration directory  \n        dependencies: ['typeorm'],\n        cli: {\n          migrationsDir: 'src/migrations',\n          entitiesDir: 'src/entities'\n        }\n      }\n      \n      return config\n    } catch (error) {\n      console.warn(`Failed to extract TypeORM config: ${error}`)\n      return null\n    }\n  }\n  \n  async getDatabaseConfig(projectPath: string): Promise<DatabaseConfig | null> {\n    try {\n      // Look for database URL in various places\n      const envFiles = ['.env', '.env.local', '.env.development']\n      const { existing: envFilesFound } = await this.checkFiles(projectPath, envFiles)\n      \n      for (const envFile of envFilesFound) {\n        const envContent = await fs.readFile(envFile.absolute, 'utf-8')\n        const dbUrl = this.extractEnvValue(envContent, 'DATABASE_URL') || \n                      this.extractEnvValue(envContent, 'DB_URL') ||\n                      this.extractEnvValue(envContent, 'TYPEORM_URL')\n        if (dbUrl) {\n          const parsed = this.parseDatabaseUrl(dbUrl)\n          if (parsed) return parsed\n        }\n      }\n      \n      // Try to extract from TypeORM config\n      const typeormConfig = await this.extractConfig(projectPath)\n      if (typeormConfig?.configFile) {\n        const configContent = await fs.readFile(typeormConfig.configFile.absolute, 'utf-8')\n        \n        // Extract database configuration from config file\n        const type = this.extractConfigValue(configContent, 'type')\n        const host = this.extractConfigValue(configContent, 'host')\n        const port = this.extractConfigValue(configContent, 'port')\n        const database = this.extractConfigValue(configContent, 'database')\n        const username = this.extractConfigValue(configContent, 'username')\n        const password = this.extractConfigValue(configContent, 'password')\n        \n        if (type && database) {\n          const dbTypeMap: Record<string, 'postgresql' | 'mysql' | 'sqlite'> = {\n            'postgres': 'postgresql',\n            'postgresql': 'postgresql',\n            'mysql': 'mysql',\n            'mariadb': 'mysql',\n            'sqlite': 'sqlite'\n          }\n          \n          const mappedType = dbTypeMap[type] || 'postgresql'\n          \n          return {\n            type: mappedType,\n            host: host || 'localhost',\n            port: port ? parseInt(port) : (mappedType === 'postgresql' ? 5432 : mappedType === 'mysql' ? 3306 : undefined),\n            database,\n            username,\n            password\n          }\n        }\n      }\n      \n      // Fallback defaults\n      return {\n        type: 'postgresql',\n        host: 'localhost',\n        port: 5432,\n        database: 'main'\n      }\n    } catch (error) {\n      console.warn(`Failed to extract database config: ${error}`)\n      return null\n    }\n  }\n  \n  private extractConfigValue(content: string, key: string): string | undefined {\n    // Simple regex-based extraction - in production, use proper AST parsing\n    const regex = new RegExp(`${key}:\\\\s*['\"]([^'\"]+)['\"]`)\n    const match = content.match(regex)\n    return match?.[1]\n  }\n  \n  private extractArrayValue(content: string, key: string): string[] | undefined {\n    // Basic array extraction - in production, use proper AST parsing\n    const regex = new RegExp(`${key}:\\\\s*\\\\[([^\\\\]]+)\\\\]`)\n    const match = content.match(regex)\n    if (!match) return undefined\n    \n    return match[1]\n      .split(',')\n      .map(item => item.trim().replace(/['\"]/g, ''))\n      .filter(item => item.length > 0)\n  }\n  \n  private extractEnvValue(content: string, key: string): string | undefined {\n    const regex = new RegExp(`^${key}\\\\s*=\\\\s*(.+)$`, 'm')\n    const match = content.match(regex)\n    return match?.[1]?.replace(/['\"]/g, '').trim()\n  }\n} ","/**\n * Database connection management\n * Handles PostgreSQL, MySQL, and SQLite connections with pooling and timeout management\n */\n\nimport { DatabaseConnection, DatabaseConfig } from '@driftjs/core'\n\n/**\n * PostgreSQL connection implementation\n */\nexport class PostgreSQLConnection implements DatabaseConnection {\n  type = 'postgresql' as const\n  isConnected = false\n  private client: any = null\n  private config: DatabaseConfig\n  \n  constructor(config: DatabaseConfig) {\n    this.config = config\n  }\n  \n  async connect(): Promise<void> {\n    try {\n      // Dynamic import to avoid bundling issues\n      const { Client } = await import('pg')\n      \n      this.client = new Client({\n        host: this.config.host,\n        port: this.config.port || 5432,\n        database: this.config.database,\n        user: this.config.username,\n        password: this.config.password,\n        ssl: this.config.ssl,\n        connectionTimeoutMillis: 10000, // 10 seconds\n        query_timeout: 30000, // 30 seconds\n      })\n      \n      await this.client.connect()\n      this.isConnected = true\n    } catch (error) {\n      this.isConnected = false\n      throw new Error(`Failed to connect to PostgreSQL: ${error}`)\n    }\n  }\n  \n  async disconnect(): Promise<void> {\n    try {\n      if (this.client) {\n        await this.client.end()\n        this.client = null\n      }\n      this.isConnected = false\n    } catch (error) {\n      console.warn(`Error disconnecting from PostgreSQL: ${error}`)\n      this.isConnected = false\n    }\n  }\n  \n  async query<T = any>(sql: string, params?: any[]): Promise<T[]> {\n    if (!this.isConnected || !this.client) {\n      throw new Error('Database not connected')\n    }\n    \n    try {\n      const result = await this.client.query(sql, params)\n      return result.rows\n    } catch (error) {\n      throw new Error(`Query failed: ${error}`)\n    }\n  }\n  \n  async transaction<T>(callback: (connection: DatabaseConnection) => Promise<T>): Promise<T> {\n    if (!this.isConnected || !this.client) {\n      throw new Error('Database not connected')\n    }\n    \n    try {\n      await this.client.query('BEGIN')\n      const result = await callback(this)\n      await this.client.query('COMMIT')\n      return result\n    } catch (error) {\n      await this.client.query('ROLLBACK')\n      throw error\n    }\n  }\n}\n\n/**\n * MySQL connection implementation\n */\nexport class MySQLConnection implements DatabaseConnection {\n  type = 'mysql' as const\n  isConnected = false\n  private connection: any = null\n  private config: DatabaseConfig\n  \n  constructor(config: DatabaseConfig) {\n    this.config = config\n  }\n  \n  async connect(): Promise<void> {\n    try {\n      // Dynamic import to avoid bundling issues\n      const mysql = await import('mysql2/promise')\n      \n             this.connection = await mysql.createConnection({\n         host: this.config.host,\n         port: this.config.port || 3306,\n         database: this.config.database,\n         user: this.config.username,\n         password: this.config.password,\n         ssl: typeof this.config.ssl === 'boolean' ? undefined : this.config.ssl\n       })\n      \n      this.isConnected = true\n    } catch (error) {\n      this.isConnected = false\n      throw new Error(`Failed to connect to MySQL: ${error}`)\n    }\n  }\n  \n  async disconnect(): Promise<void> {\n    try {\n      if (this.connection) {\n        await this.connection.end()\n        this.connection = null\n      }\n      this.isConnected = false\n    } catch (error) {\n      console.warn(`Error disconnecting from MySQL: ${error}`)\n      this.isConnected = false\n    }\n  }\n  \n  async query<T = any>(sql: string, params?: any[]): Promise<T[]> {\n    if (!this.isConnected || !this.connection) {\n      throw new Error('Database not connected')\n    }\n    \n    try {\n      const [rows] = await this.connection.execute(sql, params)\n      return Array.isArray(rows) ? rows : []\n    } catch (error) {\n      throw new Error(`Query failed: ${error}`)\n    }\n  }\n  \n  async transaction<T>(callback: (connection: DatabaseConnection) => Promise<T>): Promise<T> {\n    if (!this.isConnected || !this.connection) {\n      throw new Error('Database not connected')\n    }\n    \n    try {\n      await this.connection.beginTransaction()\n      const result = await callback(this)\n      await this.connection.commit()\n      return result\n    } catch (error) {\n      await this.connection.rollback()\n      throw error\n    }\n  }\n}\n\n/**\n * SQLite connection implementation\n */\nexport class SQLiteConnection implements DatabaseConnection {\n  type = 'sqlite' as const\n  isConnected = false\n  private db: any = null\n  private config: DatabaseConfig\n  \n  constructor(config: DatabaseConfig) {\n    this.config = config\n  }\n  \n  async connect(): Promise<void> {\n    try {\n      // Dynamic import to avoid bundling issues\n      const Database = (await import('better-sqlite3')).default\n      \n      const dbPath = this.config.database || 'database.sqlite'\n             this.db = new Database(dbPath, {\n         timeout: 10000 // 10 seconds\n       })\n      \n      this.isConnected = true\n    } catch (error) {\n      this.isConnected = false\n      throw new Error(`Failed to connect to SQLite: ${error}`)\n    }\n  }\n  \n  async disconnect(): Promise<void> {\n    try {\n      if (this.db) {\n        this.db.close()\n        this.db = null\n      }\n      this.isConnected = false\n    } catch (error) {\n      console.warn(`Error disconnecting from SQLite: ${error}`)\n      this.isConnected = false\n    }\n  }\n  \n  async query<T = any>(sql: string, params?: any[]): Promise<T[]> {\n    if (!this.isConnected || !this.db) {\n      throw new Error('Database not connected')\n    }\n    \n    try {\n      const stmt = this.db.prepare(sql)\n      const result = params ? stmt.all(params) : stmt.all()\n      return Array.isArray(result) ? result : []\n    } catch (error) {\n      throw new Error(`Query failed: ${error}`)\n    }\n  }\n  \n  async transaction<T>(callback: (connection: DatabaseConnection) => Promise<T>): Promise<T> {\n    if (!this.isConnected || !this.db) {\n      throw new Error('Database not connected')\n    }\n    \n    const transaction = this.db.transaction(async () => {\n      return await callback(this)\n    })\n    \n    return transaction()\n  }\n}\n\n/**\n * Database connection factory\n * Creates the appropriate connection based on database type\n */\nexport async function createConnection(config: DatabaseConfig): Promise<DatabaseConnection> {\n  switch (config.type) {\n    case 'postgresql':\n      return new PostgreSQLConnection(config)\n    case 'mysql':\n      return new MySQLConnection(config)\n    case 'sqlite':\n      return new SQLiteConnection(config)\n    default:\n      throw new Error(`Unsupported database type: ${config.type}`)\n  }\n}\n\n/**\n * Test database connection with proper error handling and timeout\n */\nexport async function testConnection(config: DatabaseConfig, timeoutMs: number = 10000): Promise<{ success: boolean; error?: string; latency?: number }> {\n  const startTime = Date.now()\n  let connection: DatabaseConnection | null = null\n  \n  try {\n    // Set up timeout\n    const timeoutPromise = new Promise<never>((_, reject) => {\n      setTimeout(() => reject(new Error('Connection timeout')), timeoutMs)\n    })\n    \n    // Attempt connection with timeout\n    connection = await createConnection(config)\n    await Promise.race([connection.connect(), timeoutPromise])\n    \n    // Test with a simple query\n    const testQuery = config.type === 'postgresql' \n      ? 'SELECT 1 as test' \n      : config.type === 'mysql'\n      ? 'SELECT 1 as test'\n      : 'SELECT 1 as test'\n    \n    await connection.query(testQuery)\n    \n    const latency = Date.now() - startTime\n    \n    return {\n      success: true,\n      latency\n    }\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : String(error)\n    }\n  } finally {\n    if (connection) {\n      try {\n        await connection.disconnect()\n      } catch {\n        // Ignore cleanup errors\n      }\n    }\n  }\n}\n\n/**\n * Connection pool manager for efficient connection reuse\n */\nexport class ConnectionPool {\n  private pools = new Map<string, DatabaseConnection[]>()\n  private maxPoolSize = 5\n  private minPoolSize = 1\n  \n  constructor(options?: { maxPoolSize?: number; minPoolSize?: number }) {\n    this.maxPoolSize = options?.maxPoolSize || 5\n    this.minPoolSize = options?.minPoolSize || 1\n  }\n  \n  private getPoolKey(config: DatabaseConfig): string {\n    return `${config.type}://${config.host}:${config.port}/${config.database}`\n  }\n  \n  async getConnection(config: DatabaseConfig): Promise<DatabaseConnection> {\n    const key = this.getPoolKey(config)\n    let pool = this.pools.get(key)\n    \n    if (!pool) {\n      pool = []\n      this.pools.set(key, pool)\n    }\n    \n    // Try to get an existing connection from pool\n    const connection = pool.pop()\n    if (connection && connection.isConnected) {\n      return connection\n    }\n    \n    // Create new connection if pool is empty\n    const newConnection = await createConnection(config)\n    await newConnection.connect()\n    return newConnection\n  }\n  \n  async releaseConnection(config: DatabaseConfig, connection: DatabaseConnection): Promise<void> {\n    const key = this.getPoolKey(config)\n    const pool = this.pools.get(key) || []\n    \n    if (pool.length < this.maxPoolSize && connection.isConnected) {\n      pool.push(connection)\n      this.pools.set(key, pool)\n    } else {\n      await connection.disconnect()\n    }\n  }\n  \n  async closeAll(): Promise<void> {\n    for (const pool of this.pools.values()) {\n      await Promise.all(pool.map(conn => conn.disconnect()))\n    }\n    this.pools.clear()\n  }\n} ","/**\n * Database analysis engine\n * Provides table analysis, metadata extraction, and performance impact estimation\n */\n\nimport { DatabaseConnection, TableMetadata, DatabaseAnalysis, ColumnMetadata, IndexMetadata, ConstraintMetadata } from '@driftjs/core'\n\n/**\n * Main database analyzer class\n */\nexport class DatabaseAnalyzer {\n  constructor(private connection: DatabaseConnection) {}\n  \n  /**\n   * Perform comprehensive database analysis\n   */\n  async analyze(): Promise<DatabaseAnalysis> {\n    const tables = await this.getAllTables()\n    const tableMetadata = await Promise.all(\n      tables.map(tableName => this.analyzeTable(tableName))\n    )\n    \n    const totalSize = tableMetadata.reduce((sum, table) => sum + table.sizeBytes, 0)\n    const version = await this.getDatabaseVersion()\n    const features = await this.getDatabaseFeatures()\n    const performance = await this.getPerformanceMetrics()\n    \n    return {\n      tables: tableMetadata,\n      totalSize,\n      version,\n      features,\n      performance\n    }\n  }\n  \n  /**\n   * Analyze a specific table for metadata\n   */\n  async analyzeTable(tableName: string, schema?: string): Promise<TableMetadata> {\n    const fullTableName = schema ? `${schema}.${tableName}` : tableName\n    \n    const [columns, indexes, constraints, rowCount, sizeBytes, dependencies] = await Promise.all([\n      this.getTableColumns(tableName, schema),\n      this.getTableIndexes(tableName, schema),\n      this.getTableConstraints(tableName, schema),\n      this.getTableRowCount(tableName, schema),\n      this.getTableSize(tableName, schema),\n      this.getTableDependencies(tableName, schema)\n    ])\n    \n    return {\n      name: tableName,\n      schema,\n      rowCount,\n      sizeBytes,\n      columns,\n      indexes,\n      constraints,\n      dependencies\n    }\n  }\n  \n  /**\n   * Get all table names in the database\n   */\n  private async getAllTables(): Promise<string[]> {\n    switch (this.connection.type) {\n      case 'postgresql':\n        return await this.getPostgreSQLTables()\n      case 'mysql':\n        return await this.getMySQLTables()\n      case 'sqlite':\n        return await this.getSQLiteTables()\n      default:\n        throw new Error(`Unsupported database type: ${this.connection.type}`)\n    }\n  }\n  \n  private async getPostgreSQLTables(): Promise<string[]> {\n    const result = await this.connection.query(`\n      SELECT table_name \n      FROM information_schema.tables \n      WHERE table_schema = 'public' \n      AND table_type = 'BASE TABLE'\n      ORDER BY table_name\n    `)\n    return result.map((row: any) => row.table_name)\n  }\n  \n  private async getMySQLTables(): Promise<string[]> {\n    const result = await this.connection.query(`\n      SELECT table_name \n      FROM information_schema.tables \n      WHERE table_schema = DATABASE() \n      AND table_type = 'BASE TABLE'\n      ORDER BY table_name\n    `)\n    return result.map((row: any) => row.table_name || row.TABLE_NAME)\n  }\n  \n  private async getSQLiteTables(): Promise<string[]> {\n    const result = await this.connection.query(`\n      SELECT name \n      FROM sqlite_master \n      WHERE type = 'table' \n      AND name NOT LIKE 'sqlite_%'\n      ORDER BY name\n    `)\n    return result.map((row: any) => row.name)\n  }\n  \n  /**\n   * Get column metadata for a table\n   */\n  private async getTableColumns(tableName: string, schema?: string): Promise<ColumnMetadata[]> {\n    switch (this.connection.type) {\n      case 'postgresql':\n        return await this.getPostgreSQLColumns(tableName, schema)\n      case 'mysql':\n        return await this.getMySQLColumns(tableName, schema)\n      case 'sqlite':\n        return await this.getSQLiteColumns(tableName)\n      default:\n        return []\n    }\n  }\n  \n  private async getPostgreSQLColumns(tableName: string, schema = 'public'): Promise<ColumnMetadata[]> {\n    const result = await this.connection.query(`\n      SELECT \n        c.column_name,\n        c.data_type,\n        c.is_nullable = 'YES' as nullable,\n        c.column_default as default_value,\n        CASE WHEN pk.column_name IS NOT NULL THEN true ELSE false END as is_primary,\n        CASE WHEN u.column_name IS NOT NULL THEN true ELSE false END as is_unique,\n        fk.referenced_table,\n        fk.referenced_column\n      FROM information_schema.columns c\n      LEFT JOIN (\n        SELECT ku.column_name\n        FROM information_schema.key_column_usage ku\n        JOIN information_schema.table_constraints tc ON ku.constraint_name = tc.constraint_name\n        WHERE tc.constraint_type = 'PRIMARY KEY' AND ku.table_name = $1 AND ku.table_schema = $2\n      ) pk ON c.column_name = pk.column_name\n      LEFT JOIN (\n        SELECT ku.column_name\n        FROM information_schema.key_column_usage ku\n        JOIN information_schema.table_constraints tc ON ku.constraint_name = tc.constraint_name\n        WHERE tc.constraint_type = 'UNIQUE' AND ku.table_name = $1 AND ku.table_schema = $2\n      ) u ON c.column_name = u.column_name\n      LEFT JOIN (\n        SELECT \n          ku.column_name,\n          ku.referenced_table_name as referenced_table,\n          ku.referenced_column_name as referenced_column\n        FROM information_schema.key_column_usage ku\n        JOIN information_schema.table_constraints tc ON ku.constraint_name = tc.constraint_name\n        WHERE tc.constraint_type = 'FOREIGN KEY' AND ku.table_name = $1 AND ku.table_schema = $2\n      ) fk ON c.column_name = fk.column_name\n      WHERE c.table_name = $1 AND c.table_schema = $2\n      ORDER BY c.ordinal_position\n    `, [tableName, schema])\n    \n    return result.map((row: any) => ({\n      name: row.column_name,\n      type: row.data_type,\n      nullable: row.nullable,\n      defaultValue: row.default_value,\n      isPrimary: row.is_primary,\n      isUnique: row.is_unique,\n      references: row.referenced_table ? {\n        table: row.referenced_table,\n        column: row.referenced_column\n      } : undefined\n    }))\n  }\n  \n  private async getMySQLColumns(tableName: string, schema?: string): Promise<ColumnMetadata[]> {\n    const result = await this.connection.query(`\n      SELECT \n        column_name,\n        data_type,\n        is_nullable = 'YES' as nullable,\n        column_default as default_value,\n        column_key = 'PRI' as is_primary,\n        column_key = 'UNI' as is_unique\n      FROM information_schema.columns \n      WHERE table_name = ? AND table_schema = COALESCE(?, DATABASE())\n      ORDER BY ordinal_position\n    `, [tableName, schema])\n    \n    return result.map((row: any) => ({\n      name: row.column_name || row.COLUMN_NAME,\n      type: row.data_type || row.DATA_TYPE,\n      nullable: Boolean(row.nullable),\n      defaultValue: row.default_value || row.COLUMN_DEFAULT,\n      isPrimary: Boolean(row.is_primary),\n      isUnique: Boolean(row.is_unique),\n      references: undefined // TODO: Implement FK detection for MySQL\n    }))\n  }\n  \n  private async getSQLiteColumns(tableName: string): Promise<ColumnMetadata[]> {\n    const result = await this.connection.query(`PRAGMA table_info(${tableName})`)\n    \n    return result.map((row: any) => ({\n      name: row.name,\n      type: row.type,\n      nullable: !row.notnull,\n      defaultValue: row.dflt_value,\n      isPrimary: Boolean(row.pk),\n      isUnique: false, // TODO: Implement unique detection for SQLite\n      references: undefined // TODO: Implement FK detection for SQLite\n    }))\n  }\n  \n  /**\n   * Get index metadata for a table\n   */\n  private async getTableIndexes(tableName: string, schema?: string): Promise<IndexMetadata[]> {\n    switch (this.connection.type) {\n      case 'postgresql':\n        return await this.getPostgreSQLIndexes(tableName, schema)\n      case 'mysql':\n        return await this.getMySQLIndexes(tableName, schema)\n      case 'sqlite':\n        return await this.getSQLiteIndexes(tableName)\n      default:\n        return []\n    }\n  }\n  \n  private async getPostgreSQLIndexes(tableName: string, schema = 'public'): Promise<IndexMetadata[]> {\n    const result = await this.connection.query(`\n      SELECT \n        i.indexname as name,\n        array_agg(a.attname ORDER BY a.attnum) as columns,\n        i.indexdef LIKE '%UNIQUE%' as unique,\n        am.amname as type,\n        pg_relation_size(i.indexname::regclass) as size_bytes\n      FROM pg_indexes i\n      JOIN pg_class c ON c.relname = i.indexname\n      JOIN pg_am am ON am.oid = c.relam\n      JOIN pg_index idx ON idx.indexrelid = c.oid\n      JOIN pg_attribute a ON a.attrelid = idx.indrelid AND a.attnum = ANY(idx.indkey)\n      WHERE i.tablename = $1 AND i.schemaname = $2\n      GROUP BY i.indexname, i.indexdef, am.amname, c.oid\n      ORDER BY i.indexname\n    `, [tableName, schema])\n    \n    return result.map((row: any) => ({\n      name: row.name,\n      columns: Array.isArray(row.columns) ? row.columns : [row.columns],\n      unique: row.unique,\n      type: row.type,\n      sizeBytes: parseInt(row.size_bytes) || 0\n    }))\n  }\n  \n  private async getMySQLIndexes(tableName: string, schema?: string): Promise<IndexMetadata[]> {\n    const result = await this.connection.query(`\n      SELECT \n        index_name as name,\n        GROUP_CONCAT(column_name ORDER BY seq_in_index) as columns,\n        non_unique = 0 as unique,\n        index_type as type\n      FROM information_schema.statistics \n      WHERE table_name = ? AND table_schema = COALESCE(?, DATABASE())\n      GROUP BY index_name, non_unique, index_type\n      ORDER BY index_name\n    `, [tableName, schema])\n    \n    return result.map((row: any) => ({\n      name: row.name,\n      columns: row.columns.split(','),\n      unique: Boolean(row.unique),\n      type: row.type,\n      sizeBytes: undefined // Size info not easily available in MySQL\n    }))\n  }\n  \n  private async getSQLiteIndexes(tableName: string): Promise<IndexMetadata[]> {\n    const result = await this.connection.query(`\n      SELECT name, sql \n      FROM sqlite_master \n      WHERE type = 'index' AND tbl_name = ?\n    `, [tableName])\n    \n    return result.map((row: any) => ({\n      name: row.name,\n      columns: [], // TODO: Parse from SQL\n      unique: row.sql?.includes('UNIQUE') || false,\n      type: 'btree',\n      sizeBytes: undefined\n    }))\n  }\n  \n  /**\n   * Get constraint metadata for a table\n   */\n  private async getTableConstraints(tableName: string, schema?: string): Promise<ConstraintMetadata[]> {\n    switch (this.connection.type) {\n      case 'postgresql':\n        return await this.getPostgreSQLConstraints(tableName, schema)\n      case 'mysql':\n        return await this.getMySQLConstraints(tableName, schema)\n      case 'sqlite':\n        return await this.getSQLiteConstraints(tableName)\n      default:\n        return []\n    }\n  }\n  \n  private async getPostgreSQLConstraints(tableName: string, schema = 'public'): Promise<ConstraintMetadata[]> {\n    const result = await this.connection.query(`\n      SELECT \n        tc.constraint_name as name,\n        tc.constraint_type as type,\n        array_agg(kcu.column_name) as columns,\n        ccu.table_name as referenced_table,\n        array_agg(ccu.column_name) as referenced_columns,\n        cc.check_clause as definition\n      FROM information_schema.table_constraints tc\n      LEFT JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name\n      LEFT JOIN information_schema.constraint_column_usage ccu ON tc.constraint_name = ccu.constraint_name\n      LEFT JOIN information_schema.check_constraints cc ON tc.constraint_name = cc.constraint_name\n      WHERE tc.table_name = $1 AND tc.table_schema = $2\n      GROUP BY tc.constraint_name, tc.constraint_type, ccu.table_name, cc.check_clause\n      ORDER BY tc.constraint_name\n    `, [tableName, schema])\n    \n    return result.map((row: any) => ({\n      name: row.name,\n      type: row.type,\n      columns: Array.isArray(row.columns) ? row.columns.filter(Boolean) : [row.columns].filter(Boolean),\n      referencedTable: row.referenced_table,\n      referencedColumns: Array.isArray(row.referenced_columns) ? row.referenced_columns.filter(Boolean) : [row.referenced_columns].filter(Boolean),\n      definition: row.definition\n    }))\n  }\n  \n  private async getMySQLConstraints(tableName: string, schema?: string): Promise<ConstraintMetadata[]> {\n    // Simplified MySQL constraint detection\n    return []\n  }\n  \n  private async getSQLiteConstraints(tableName: string): Promise<ConstraintMetadata[]> {\n    // Simplified SQLite constraint detection\n    return []\n  }\n  \n  /**\n   * Get table row count\n   */\n  private async getTableRowCount(tableName: string, schema?: string): Promise<number> {\n    try {\n      const fullTableName = schema ? `${schema}.${tableName}` : tableName\n      const result = await this.connection.query(`SELECT COUNT(*) as count FROM ${fullTableName}`)\n      return parseInt(result[0]?.count || result[0]?.COUNT || '0')\n    } catch {\n      return 0\n    }\n  }\n  \n  /**\n   * Get table size in bytes\n   */\n  private async getTableSize(tableName: string, schema?: string): Promise<number> {\n    try {\n      switch (this.connection.type) {\n        case 'postgresql':\n          const pgResult = await this.connection.query(`\n            SELECT pg_total_relation_size($1) as size\n          `, [tableName])\n          return parseInt(pgResult[0]?.size || '0')\n          \n        case 'mysql':\n          const mysqlResult = await this.connection.query(`\n            SELECT (data_length + index_length) as size\n            FROM information_schema.tables\n            WHERE table_name = ? AND table_schema = COALESCE(?, DATABASE())\n          `, [tableName, schema])\n          return parseInt(mysqlResult[0]?.size || '0')\n          \n        case 'sqlite':\n          // SQLite doesn't have easy size calculation\n          return 0\n          \n        default:\n          return 0\n      }\n    } catch {\n      return 0\n    }\n  }\n  \n  /**\n   * Get table dependencies\n   */\n  private async getTableDependencies(tableName: string, schema?: string): Promise<any[]> {\n    // Simplified implementation - return empty for now\n    return []\n  }\n  \n  /**\n   * Get database version\n   */\n  private async getDatabaseVersion(): Promise<string> {\n    try {\n      switch (this.connection.type) {\n        case 'postgresql':\n          const pgResult = await this.connection.query('SELECT version()')\n          return pgResult[0]?.version || 'Unknown'\n          \n        case 'mysql':\n          const mysqlResult = await this.connection.query('SELECT VERSION() as version')\n          return mysqlResult[0]?.version || 'Unknown'\n          \n        case 'sqlite':\n          const sqliteResult = await this.connection.query('SELECT sqlite_version()')\n          return sqliteResult[0]?.['sqlite_version()'] || 'Unknown'\n          \n        default:\n          return 'Unknown'\n      }\n    } catch {\n      return 'Unknown'\n    }\n  }\n  \n  /**\n   * Get database features\n   */\n  private async getDatabaseFeatures(): Promise<string[]> {\n    const features: string[] = []\n    \n    switch (this.connection.type) {\n      case 'postgresql':\n        features.push('ACID', 'Transactions', 'Foreign Keys', 'Indexes', 'Views', 'Triggers', 'Stored Procedures')\n        break\n      case 'mysql':\n        features.push('ACID', 'Transactions', 'Foreign Keys', 'Indexes', 'Views', 'Triggers', 'Stored Procedures')\n        break\n      case 'sqlite':\n        features.push('ACID', 'Transactions', 'Foreign Keys', 'Indexes', 'Views', 'Triggers')\n        break\n    }\n    \n    return features\n  }\n  \n  /**\n   * Get performance metrics\n   */\n  private async getPerformanceMetrics(): Promise<{ avgQueryTime: number; connectionCount: number; cacheHitRatio?: number }> {\n    // Simplified implementation\n    return {\n      avgQueryTime: 0,\n      connectionCount: 1,\n      cacheHitRatio: undefined\n    }\n  }\n  \n  /**\n   * Estimate migration performance impact\n   */\n  async estimatePerformanceImpact(sql: string, tableName?: string): Promise<{\n    estimatedTime: number\n    lockDuration: number\n    affectedRows: number\n    riskLevel: 'LOW' | 'MEDIUM' | 'HIGH'\n    recommendations: string[]\n  }> {\n    const recommendations: string[] = []\n    let riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' = 'LOW'\n    let estimatedTime = 0\n    let lockDuration = 0\n    let affectedRows = 0\n    \n    // Basic SQL analysis\n    const sqlLower = sql.toLowerCase()\n    \n    if (tableName) {\n      const tableMetadata = await this.analyzeTable(tableName)\n      affectedRows = tableMetadata.rowCount\n      \n      // Estimate based on table size and operation type\n      if (sqlLower.includes('alter table')) {\n        estimatedTime = Math.max(1, Math.floor(affectedRows / 1000)) // 1 second per 1000 rows\n        lockDuration = estimatedTime\n        \n        if (affectedRows > 100000) {\n          riskLevel = 'HIGH'\n          recommendations.push('Consider maintenance window for large table migration')\n          recommendations.push('Test migration on staging environment first')\n        } else if (affectedRows > 10000) {\n          riskLevel = 'MEDIUM'\n          recommendations.push('Monitor migration progress')\n        }\n        \n        if (sqlLower.includes('add column') && !sqlLower.includes('not null')) {\n          recommendations.push('Adding nullable column is generally safe')\n        } else if (sqlLower.includes('add column') && sqlLower.includes('not null')) {\n          riskLevel = 'HIGH'\n          recommendations.push('Adding NOT NULL column requires table rewrite')\n          recommendations.push('Consider adding column as nullable first, then adding constraint')\n        }\n      }\n      \n      if (sqlLower.includes('drop column')) {\n        riskLevel = 'HIGH'\n        recommendations.push('Dropping columns is destructive - ensure data is not needed')\n        recommendations.push('Consider creating backup before migration')\n      }\n      \n      if (sqlLower.includes('create index')) {\n        estimatedTime = Math.max(1, Math.floor(affectedRows / 5000)) // 1 second per 5000 rows\n        lockDuration = 0 // Most databases support CONCURRENT index creation\n        \n        if (this.connection.type === 'postgresql') {\n          recommendations.push('Use CREATE INDEX CONCURRENTLY to avoid blocking')\n        }\n      }\n    }\n    \n    return {\n      estimatedTime,\n      lockDuration,\n      affectedRows,\n      riskLevel,\n      recommendations\n    }\n  }\n} ","/**\n * Database adapter interfaces (placeholder)\n */\n\nimport { DatabaseType } from '@driftjs/core'\n\nexport interface DatabaseAdapter {\n  type: DatabaseType\n  supportsFeature(feature: string): boolean\n  getOptimalIndexType(columns: string[]): string\n  estimateOperationTime(operation: string, tableSize: number): number\n}\n\nexport class PostgreSQLAdapter implements DatabaseAdapter {\n  type = 'postgresql' as const\n  \n  supportsFeature(feature: string): boolean {\n    // TODO: Implement PostgreSQL feature detection\n    return false\n  }\n  \n  getOptimalIndexType(columns: string[]): string {\n    // TODO: Implement PostgreSQL index optimization\n    return 'btree'\n  }\n  \n  estimateOperationTime(operation: string, tableSize: number): number {\n    // TODO: Implement PostgreSQL operation time estimation\n    return 0\n  }\n} "],"mappings":"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","names":["createFilePath","fs"]}