{"version":3,"sources":["../src/index.ts","../src/parsers/sql-parser.ts","../src/parsers/ast-analyzer.ts","../src/parsers/migration-parser.ts","../src/risk-detector.ts","../src/strategy-generator.ts","../src/enhancement-engine.ts"],"sourcesContent":["// SQL enhancement engine for DriftJS\nexport * from './parsers/index.js'\nexport * from './enhancers/index.js' ","import pkg from 'node-sql-parser';\nconst { Parser } = pkg;\nimport type { AST, Parser as ParserType } from 'node-sql-parser';\n\n/**\n * SQL operation types that can be parsed and analyzed\n */\nexport enum SqlOperationType {\n  CREATE_TABLE = 'CREATE_TABLE',\n  ALTER_TABLE = 'ALTER_TABLE',\n  DROP_TABLE = 'DROP_TABLE',\n  CREATE_INDEX = 'CREATE_INDEX',\n  DROP_INDEX = 'DROP_INDEX',\n  INSERT = 'INSERT',\n  UPDATE = 'UPDATE',\n  DELETE = 'DELETE',\n  SELECT = 'SELECT',\n  UNKNOWN = 'UNKNOWN'\n}\n\n/**\n * Parsed SQL operation with metadata\n */\nexport interface ParsedSqlOperation {\n  type: SqlOperationType;\n  sql: string;\n  ast: AST | null;\n  tableName?: string;\n  columnName?: string;\n  indexName?: string;\n  operation?: string;\n  metadata: {\n    isBlocking: boolean;\n    isDestructive: boolean;\n    affectsData: boolean;\n    requiresLock: boolean;\n    estimatedDuration: 'fast' | 'medium' | 'slow';\n  };\n}\n\n/**\n * SQL parsing result with all operations found\n */\nexport interface SqlParseResult {\n  operations: ParsedSqlOperation[];\n  errors: string[];\n  warnings: string[];\n  totalOperations: number;\n  destructiveOperations: number;\n  blockingOperations: number;\n}\n\n/**\n * SQL Parser class for analyzing migration SQL statements\n */\nexport class SqlParser {\n  private parser: ParserType;\n\n  constructor() {\n    // Initialize node-sql-parser with multiple database support\n    this.parser = new Parser();\n  }\n\n  /**\n   * Parse a single SQL statement and return operation details\n   */\n  public parseSql(sql: string, database: 'postgresql' | 'mysql' | 'sqlite' = 'postgresql'): ParsedSqlOperation {\n    try {\n      // Clean and normalize the SQL\n      const cleanSql = this.cleanSql(sql);\n      \n      // Parse the SQL into AST\n      const ast = this.parser.astify(cleanSql, { database });\n      \n      // Extract operation details\n      const operation = this.extractOperationFromAst(ast, cleanSql);\n      \n      return operation;\n    } catch (error) {\n      // If parsing fails, try to determine operation type from SQL text\n      const fallbackOperation = this.fallbackParse(sql);\n      return {\n        ...fallbackOperation,\n        ast: null,\n        metadata: {\n          ...fallbackOperation.metadata,\n          estimatedDuration: 'medium' // Default to medium for unparseable operations\n        }\n      };\n    }\n  }\n\n  /**\n   * Parse multiple SQL statements (common in migration files)\n   */\n  public parseMultipleSql(sqlStatements: string[], database: 'postgresql' | 'mysql' | 'sqlite' = 'postgresql'): SqlParseResult {\n    const operations: ParsedSqlOperation[] = [];\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    for (const sql of sqlStatements) {\n      try {\n        const operation = this.parseSql(sql, database);\n        operations.push(operation);\n\n        // Add warnings for risky operations\n        if (operation.metadata.isDestructive) {\n          warnings.push(`Destructive operation detected: ${operation.type} on ${operation.tableName || 'unknown table'}`);\n        }\n        if (operation.metadata.isBlocking) {\n          warnings.push(`Blocking operation detected: ${operation.type} - may cause downtime`);\n        }\n      } catch (error) {\n        errors.push(`Failed to parse SQL: ${sql.substring(0, 50)}... - ${error}`);\n      }\n    }\n\n    return {\n      operations,\n      errors,\n      warnings,\n      totalOperations: operations.length,\n      destructiveOperations: operations.filter(op => op.metadata.isDestructive).length,\n      blockingOperations: operations.filter(op => op.metadata.isBlocking).length\n    };\n  }\n\n  /**\n   * Clean and normalize SQL for better parsing\n   */\n  private cleanSql(sql: string): string {\n    return sql\n      .trim()\n      .replace(/\\s+/g, ' ') // Normalize whitespace\n      .replace(/;\\s*$/, ''); // Remove trailing semicolon\n  }\n\n  /**\n   * Extract operation details from parsed AST\n   */\n  private extractOperationFromAst(ast: AST | AST[], sql: string): ParsedSqlOperation {\n    // Handle array of AST nodes\n    if (Array.isArray(ast)) {\n      ast = ast[0]; // Take the first statement\n    }\n\n    const operation: ParsedSqlOperation = {\n      type: SqlOperationType.UNKNOWN,\n      sql,\n      ast,\n      metadata: {\n        isBlocking: false,\n        isDestructive: false,\n        affectsData: false,\n        requiresLock: false,\n        estimatedDuration: 'fast'\n      }\n    };\n\n    // Cast to any to handle different AST node types\n    const astNode = ast as any;\n\n    switch (astNode.type?.toLowerCase()) {\n      case 'create':\n        if (astNode.keyword === 'table') {\n          operation.type = SqlOperationType.CREATE_TABLE;\n          operation.tableName = this.extractTableName(astNode);\n          operation.metadata = {\n            isBlocking: true,\n            isDestructive: false,\n            affectsData: false,\n            requiresLock: true,\n            estimatedDuration: 'medium'\n          };\n        } else if (astNode.keyword === 'index') {\n          operation.type = SqlOperationType.CREATE_INDEX;\n          operation.indexName = astNode.index;\n          operation.tableName = this.extractTableName(astNode);\n          operation.metadata = {\n            isBlocking: true,\n            isDestructive: false,\n            affectsData: false,\n            requiresLock: true,\n            estimatedDuration: 'slow'\n          };\n        }\n        break;\n\n      case 'alter':\n        operation.type = SqlOperationType.ALTER_TABLE;\n        operation.tableName = this.extractTableName(astNode);\n        operation.operation = astNode.expr?.type || 'unknown';\n        \n        // Analyze the specific ALTER operation\n        const alterMetadata = this.analyzeAlterOperation(astNode);\n        operation.metadata = alterMetadata;\n        break;\n\n      case 'drop':\n        if (astNode.keyword === 'table') {\n          operation.type = SqlOperationType.DROP_TABLE;\n          operation.tableName = this.extractTableName(astNode);\n          operation.metadata = {\n            isBlocking: true,\n            isDestructive: true,\n            affectsData: true,\n            requiresLock: true,\n            estimatedDuration: 'fast'\n          };\n        } else if (astNode.keyword === 'index') {\n          operation.type = SqlOperationType.DROP_INDEX;\n          operation.indexName = astNode.name;\n          operation.metadata = {\n            isBlocking: false,\n            isDestructive: true,\n            affectsData: false,\n            requiresLock: false,\n            estimatedDuration: 'fast'\n          };\n        }\n        break;\n\n      case 'insert':\n        operation.type = SqlOperationType.INSERT;\n        operation.tableName = this.extractTableName(astNode);\n        operation.metadata = {\n          isBlocking: false,\n          isDestructive: false,\n          affectsData: true,\n          requiresLock: false,\n          estimatedDuration: 'fast'\n        };\n        break;\n\n      case 'update':\n        operation.type = SqlOperationType.UPDATE;\n        operation.tableName = this.extractTableName(astNode);\n        operation.metadata = {\n          isBlocking: false,\n          isDestructive: false,\n          affectsData: true,\n          requiresLock: false,\n          estimatedDuration: 'medium'\n        };\n        break;\n\n      case 'delete':\n        operation.type = SqlOperationType.DELETE;\n        operation.tableName = this.extractTableName(astNode);\n        operation.metadata = {\n          isBlocking: false,\n          isDestructive: true,\n          affectsData: true,\n          requiresLock: false,\n          estimatedDuration: 'medium'\n        };\n        break;\n\n      case 'select':\n        operation.type = SqlOperationType.SELECT;\n        operation.tableName = this.extractTableName(astNode);\n        operation.metadata = {\n          isBlocking: false,\n          isDestructive: false,\n          affectsData: false,\n          requiresLock: false,\n          estimatedDuration: 'fast'\n        };\n        break;\n    }\n\n    return operation;\n  }\n\n  /**\n   * Analyze ALTER TABLE operations for specific risk assessment\n   */\n  private analyzeAlterOperation(ast: any): ParsedSqlOperation['metadata'] {\n    const baseMetadata = {\n      isBlocking: true,\n      isDestructive: false,\n      affectsData: false,\n      requiresLock: true,\n      estimatedDuration: 'medium' as const\n    };\n\n    // Check for specific ALTER operations\n    if (ast.expr) {\n      const action = ast.expr.action?.toLowerCase();\n      \n      switch (action) {\n        case 'add':\n          if (ast.expr.resource === 'column') {\n            // Adding NOT NULL column is blocking and potentially destructive\n            const hasNotNull = ast.expr.definition?.nullable === false;\n            const hasDefault = ast.expr.definition?.defaultValue !== undefined;\n            \n            return {\n              ...baseMetadata,\n              isDestructive: hasNotNull && !hasDefault,\n              estimatedDuration: hasNotNull ? 'slow' : 'medium'\n            };\n          }\n          break;\n\n        case 'drop':\n          return {\n            ...baseMetadata,\n            isDestructive: true,\n            affectsData: true,\n            estimatedDuration: 'fast'\n          };\n\n        case 'modify':\n        case 'change':\n          return {\n            ...baseMetadata,\n            isDestructive: true,\n            affectsData: true,\n            estimatedDuration: 'slow'\n          };\n\n        case 'rename':\n          return {\n            ...baseMetadata,\n            isDestructive: false,\n            affectsData: false,\n            estimatedDuration: 'fast'\n          };\n      }\n    }\n\n    return baseMetadata;\n  }\n\n  /**\n   * Extract table name from AST node\n   */\n  private extractTableName(ast: any): string | undefined {\n    if (ast.table) {\n      return typeof ast.table === 'string' ? ast.table : ast.table.table;\n    }\n    if (ast.name) {\n      return typeof ast.name === 'string' ? ast.name : ast.name.table;\n    }\n    if (ast.from && ast.from.length > 0) {\n      const fromTable = ast.from[0];\n      return typeof fromTable.table === 'string' ? fromTable.table : fromTable.table?.table;\n    }\n    return undefined;\n  }\n\n  /**\n   * Fallback parsing when AST parsing fails\n   */\n  private fallbackParse(sql: string): Omit<ParsedSqlOperation, 'ast'> {\n    const upperSql = sql.toUpperCase().trim();\n    \n    // Extract operation type from SQL text\n    let type = SqlOperationType.UNKNOWN;\n    let tableName: string | undefined;\n    let isBlocking = false;\n    let isDestructive = false;\n    let affectsData = false;\n    let requiresLock = false;\n    let estimatedDuration: 'fast' | 'medium' | 'slow' = 'medium';\n\n    if (upperSql.startsWith('CREATE TABLE')) {\n      type = SqlOperationType.CREATE_TABLE;\n      tableName = this.extractTableNameFromText(sql, 'CREATE TABLE');\n      isBlocking = true;\n      requiresLock = true;\n    } else if (upperSql.startsWith('CREATE INDEX')) {\n      type = SqlOperationType.CREATE_INDEX;\n      isBlocking = true;\n      requiresLock = true;\n      estimatedDuration = 'slow';\n    } else if (upperSql.startsWith('ALTER TABLE')) {\n      type = SqlOperationType.ALTER_TABLE;\n      tableName = this.extractTableNameFromText(sql, 'ALTER TABLE');\n      isBlocking = true;\n      requiresLock = true;\n      \n      // Check for destructive ALTER operations\n      if (upperSql.includes('DROP COLUMN') || upperSql.includes('DROP CONSTRAINT')) {\n        isDestructive = true;\n        affectsData = true;\n      }\n    } else if (upperSql.startsWith('DROP TABLE')) {\n      type = SqlOperationType.DROP_TABLE;\n      tableName = this.extractTableNameFromText(sql, 'DROP TABLE');\n      isBlocking = true;\n      isDestructive = true;\n      affectsData = true;\n      requiresLock = true;\n      estimatedDuration = 'fast';\n    } else if (upperSql.startsWith('DROP INDEX')) {\n      type = SqlOperationType.DROP_INDEX;\n      isDestructive = true;\n      estimatedDuration = 'fast';\n    } else if (upperSql.startsWith('INSERT')) {\n      type = SqlOperationType.INSERT;\n      affectsData = true;\n      estimatedDuration = 'fast';\n    } else if (upperSql.startsWith('UPDATE')) {\n      type = SqlOperationType.UPDATE;\n      affectsData = true;\n    } else if (upperSql.startsWith('DELETE')) {\n      type = SqlOperationType.DELETE;\n      isDestructive = true;\n      affectsData = true;\n    } else if (upperSql.startsWith('SELECT')) {\n      type = SqlOperationType.SELECT;\n      estimatedDuration = 'fast';\n    }\n\n    return {\n      type,\n      sql,\n      tableName,\n      metadata: {\n        isBlocking,\n        isDestructive,\n        affectsData,\n        requiresLock,\n        estimatedDuration\n      }\n    };\n  }\n\n  /**\n   * Extract table name from SQL text using regex\n   */\n  private extractTableNameFromText(sql: string, operation: string): string | undefined {\n    const regex = new RegExp(`${operation}\\\\s+(?:IF\\\\s+(?:NOT\\\\s+)?EXISTS\\\\s+)?(?:\\`|\\\"|\\\\[)?([\\\\w_]+)(?:\\`|\\\"|\\\\])?`, 'i');\n    const match = sql.match(regex);\n    return match ? match[1] : undefined;\n  }\n} ","import type { AST } from 'node-sql-parser';\nimport type { ParsedSqlOperation, SqlOperationType } from './sql-parser.js';\n\n/**\n * Column definition extracted from AST\n */\nexport interface ColumnDefinition {\n  name: string;\n  type: string;\n  nullable: boolean;\n  primaryKey: boolean;\n  unique: boolean;\n  defaultValue?: string | number | boolean;\n  autoIncrement: boolean;\n  references?: {\n    table: string;\n    column: string;\n    onDelete?: string;\n    onUpdate?: string;\n  };\n}\n\n/**\n * Index definition extracted from AST\n */\nexport interface IndexDefinition {\n  name: string;\n  columns: string[];\n  unique: boolean;\n  type?: string; // btree, hash, etc.\n  tableName: string;\n  concurrent?: boolean;\n}\n\n/**\n * Constraint definition extracted from AST\n */\nexport interface ConstraintDefinition {\n  name?: string;\n  type: 'PRIMARY_KEY' | 'FOREIGN_KEY' | 'UNIQUE' | 'CHECK' | 'NOT_NULL';\n  columns: string[];\n  tableName: string;\n  referencedTable?: string;\n  referencedColumns?: string[];\n  onDelete?: string;\n  onUpdate?: string;\n  checkExpression?: string;\n}\n\n/**\n * Table dependency relationship\n */\nexport interface TableDependency {\n  sourceTable: string;\n  targetTable: string;\n  type: 'FOREIGN_KEY' | 'REFERENCE' | 'JOIN';\n  columns: string[];\n  referencedColumns: string[];\n}\n\n/**\n * Operation dependency between SQL operations\n */\nexport interface OperationDependency {\n  operation: ParsedSqlOperation;\n  dependsOn: ParsedSqlOperation[];\n  dependencyType: 'TABLE_CREATION' | 'DATA_DEPENDENCY' | 'CONSTRAINT_DEPENDENCY' | 'INDEX_DEPENDENCY';\n  reason: string;\n}\n\n/**\n * Analysis result for a SQL operation\n */\nexport interface SqlOperationAnalysis {\n  operation: ParsedSqlOperation;\n  columns: ColumnDefinition[];\n  indexes: IndexDefinition[];\n  constraints: ConstraintDefinition[];\n  dependencies: TableDependency[];\n  complexity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n  estimatedExecutionTime: number; // in milliseconds\n  memoryUsage: 'LOW' | 'MEDIUM' | 'HIGH';\n  lockScope: 'NONE' | 'ROW' | 'TABLE' | 'DATABASE';\n}\n\n/**\n * Complete analysis result for multiple operations\n */\nexport interface MigrationAnalysisResult {\n  operations: SqlOperationAnalysis[];\n  operationDependencies: OperationDependency[];\n  totalComplexity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n  estimatedTotalTime: number;\n  riskFactors: string[];\n  recommendations: string[];\n}\n\n/**\n * AST Analyzer class for deep SQL operation analysis\n */\nexport class AstAnalyzer {\n  /**\n   * Analyze a single SQL operation and its AST\n   */\n  public analyzeSqlOperation(operation: ParsedSqlOperation): SqlOperationAnalysis {\n    const analysis: SqlOperationAnalysis = {\n      operation,\n      columns: [],\n      indexes: [],\n      constraints: [],\n      dependencies: [],\n      complexity: 'LOW',\n      estimatedExecutionTime: 100,\n      memoryUsage: 'LOW',\n      lockScope: 'NONE'\n    };\n\n    if (!operation.ast) {\n      // If no AST, provide basic analysis based on operation type\n      return this.analyzeWithoutAst(operation);\n    }\n\n    // Cast AST to any for easier property access\n    const ast = operation.ast as any;\n\n    switch (operation.type) {\n      case 'CREATE_TABLE':\n        return this.analyzeCreateTable(operation, ast);\n      case 'ALTER_TABLE':\n        return this.analyzeAlterTable(operation, ast);\n      case 'CREATE_INDEX':\n        return this.analyzeCreateIndex(operation, ast);\n      case 'DROP_TABLE':\n        return this.analyzeDropTable(operation, ast);\n      case 'DROP_INDEX':\n        return this.analyzeDropIndex(operation, ast);\n      default:\n        return this.analyzeGenericOperation(operation, ast);\n    }\n  }\n\n  /**\n   * Analyze multiple operations and their dependencies\n   */\n  public analyzeMigration(operations: ParsedSqlOperation[]): MigrationAnalysisResult {\n    const operationAnalyses = operations.map(op => this.analyzeSqlOperation(op));\n    const operationDependencies = this.identifyOperationDependencies(operationAnalyses);\n    \n    const totalComplexity = this.calculateTotalComplexity(operationAnalyses);\n    const estimatedTotalTime = operationAnalyses.reduce((sum, analysis) => sum + analysis.estimatedExecutionTime, 0);\n    const riskFactors = this.identifyRiskFactors(operationAnalyses);\n    const recommendations = this.generateRecommendations(operationAnalyses, operationDependencies);\n\n    return {\n      operations: operationAnalyses,\n      operationDependencies,\n      totalComplexity,\n      estimatedTotalTime,\n      riskFactors,\n      recommendations\n    };\n  }\n\n  /**\n   * Analyze CREATE TABLE operation\n   */\n  private analyzeCreateTable(operation: ParsedSqlOperation, ast: any): SqlOperationAnalysis {\n    const columns = this.extractColumns(ast);\n    const constraints = this.extractConstraints(ast, operation.tableName || '');\n    const dependencies = this.extractTableDependencies(ast, operation.tableName || '');\n\n    return {\n      operation,\n      columns,\n      indexes: [],\n      constraints,\n      dependencies,\n      complexity: columns.length > 20 ? 'HIGH' : columns.length > 10 ? 'MEDIUM' : 'LOW',\n      estimatedExecutionTime: this.estimateCreateTableTime(columns.length, constraints.length),\n      memoryUsage: columns.length > 50 ? 'HIGH' : columns.length > 20 ? 'MEDIUM' : 'LOW',\n      lockScope: 'TABLE'\n    };\n  }\n\n  /**\n   * Analyze ALTER TABLE operation\n   */\n  private analyzeAlterTable(operation: ParsedSqlOperation, ast: any): SqlOperationAnalysis {\n    const alterType = ast.expr?.action?.toLowerCase();\n    let complexity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' = 'MEDIUM';\n    let estimatedTime = 1000; // Default 1 second\n    let lockScope: 'NONE' | 'ROW' | 'TABLE' | 'DATABASE' = 'TABLE';\n\n    // Analyze specific ALTER operations\n    switch (alterType) {\n      case 'add':\n        if (ast.expr?.resource === 'column') {\n          const hasNotNull = ast.expr?.definition?.nullable === false;\n          const hasDefault = ast.expr?.definition?.defaultValue !== undefined;\n          complexity = hasNotNull && !hasDefault ? 'HIGH' : 'MEDIUM';\n          estimatedTime = hasNotNull ? 10000 : 2000; // 10 sec for NOT NULL, 2 sec for nullable\n        }\n        break;\n      case 'drop':\n        complexity = 'HIGH';\n        estimatedTime = 5000; // 5 seconds\n        break;\n      case 'modify':\n      case 'change':\n        complexity = 'CRITICAL';\n        estimatedTime = 15000; // 15 seconds\n        break;\n      case 'rename':\n        complexity = 'LOW';\n        estimatedTime = 500; // 0.5 seconds\n        lockScope = 'NONE';\n        break;\n    }\n\n    return {\n      operation,\n      columns: [],\n      indexes: [],\n      constraints: [],\n      dependencies: [],\n      complexity,\n      estimatedExecutionTime: estimatedTime,\n      memoryUsage: complexity === 'CRITICAL' ? 'HIGH' : 'MEDIUM',\n      lockScope\n    };\n  }\n\n  /**\n   * Analyze CREATE INDEX operation\n   */\n  private analyzeCreateIndex(operation: ParsedSqlOperation, ast: any): SqlOperationAnalysis {\n    const indexDef = this.extractIndexDefinition(ast, operation.tableName || '');\n    const isConcurrent = ast.options?.includes('CONCURRENTLY') || false;\n    \n    return {\n      operation,\n      columns: [],\n      indexes: indexDef ? [indexDef] : [],\n      constraints: [],\n      dependencies: [],\n      complexity: indexDef && indexDef.columns.length > 3 ? 'HIGH' : 'MEDIUM',\n      estimatedExecutionTime: isConcurrent ? 30000 : 15000, // 30s concurrent, 15s blocking\n      memoryUsage: 'MEDIUM',\n      lockScope: isConcurrent ? 'NONE' : 'TABLE'\n    };\n  }\n\n  /**\n   * Analyze DROP TABLE operation\n   */\n  private analyzeDropTable(operation: ParsedSqlOperation, ast: any): SqlOperationAnalysis {\n    return {\n      operation,\n      columns: [],\n      indexes: [],\n      constraints: [],\n      dependencies: [],\n      complexity: 'MEDIUM',\n      estimatedExecutionTime: 2000, // 2 seconds\n      memoryUsage: 'LOW',\n      lockScope: 'TABLE'\n    };\n  }\n\n  /**\n   * Analyze DROP INDEX operation\n   */\n  private analyzeDropIndex(operation: ParsedSqlOperation, ast: any): SqlOperationAnalysis {\n    const isConcurrent = ast.options?.includes('CONCURRENTLY') || false;\n    \n    return {\n      operation,\n      columns: [],\n      indexes: [],\n      constraints: [],\n      dependencies: [],\n      complexity: 'LOW',\n      estimatedExecutionTime: isConcurrent ? 10000 : 1000, // 10s concurrent, 1s blocking\n      memoryUsage: 'LOW',\n      lockScope: isConcurrent ? 'NONE' : 'TABLE'\n    };\n  }\n\n  /**\n   * Analyze generic operation without specific handlers\n   */\n  private analyzeGenericOperation(operation: ParsedSqlOperation, ast: any): SqlOperationAnalysis {\n    return {\n      operation,\n      columns: [],\n      indexes: [],\n      constraints: [],\n      dependencies: [],\n      complexity: operation.metadata.isDestructive ? 'HIGH' : 'MEDIUM',\n      estimatedExecutionTime: this.estimateGenericOperationTime(operation),\n      memoryUsage: 'MEDIUM',\n      lockScope: operation.metadata.requiresLock ? 'TABLE' : 'ROW'\n    };\n  }\n\n  /**\n   * Analyze operation without AST\n   */\n  private analyzeWithoutAst(operation: ParsedSqlOperation): SqlOperationAnalysis {\n    return {\n      operation,\n      columns: [],\n      indexes: [],\n      constraints: [],\n      dependencies: [],\n      complexity: operation.metadata.isDestructive ? 'HIGH' : operation.metadata.isBlocking ? 'MEDIUM' : 'LOW',\n      estimatedExecutionTime: this.estimateGenericOperationTime(operation),\n      memoryUsage: operation.metadata.isBlocking ? 'MEDIUM' : 'LOW',\n      lockScope: operation.metadata.requiresLock ? 'TABLE' : operation.metadata.affectsData ? 'ROW' : 'NONE'\n    };\n  }\n\n  /**\n   * Extract column definitions from CREATE TABLE AST\n   */\n  private extractColumns(ast: any): ColumnDefinition[] {\n    if (!ast.create_definitions) return [];\n\n    return ast.create_definitions\n      .filter((def: any) => def.resource === 'column')\n      .map((colDef: any) => ({\n        name: colDef.column?.column || colDef.column,\n        type: this.extractColumnType(colDef.definition),\n        nullable: colDef.definition?.nullable !== false,\n        primaryKey: colDef.definition?.primary_key === true,\n        unique: colDef.definition?.unique === true,\n        autoIncrement: colDef.definition?.auto_increment === true,\n        defaultValue: colDef.definition?.default_val?.value\n      }));\n  }\n\n  /**\n   * Extract column type from definition\n   */  \n  private extractColumnType(definition: any): string {\n    if (!definition?.dataType) return 'UNKNOWN';\n    \n    let type = definition.dataType;\n    if (definition.length) {\n      type += `(${definition.length.join(',')})`;\n    }\n    return type.toUpperCase();\n  }\n\n  /**\n   * Extract constraints from table definition\n   */\n  private extractConstraints(ast: any, tableName: string): ConstraintDefinition[] {\n    const constraints: ConstraintDefinition[] = [];\n\n    if (!ast.create_definitions) return constraints;\n\n    for (const def of ast.create_definitions) {\n      if (def.resource === 'constraint') {\n        const constraint: ConstraintDefinition = {\n          name: def.constraint,\n          type: this.mapConstraintType(def.constraint_type),\n          columns: def.definition?.column?.map((col: any) => col.column) || [],\n          tableName\n        };\n\n        if (def.definition?.reference_definition) {\n          constraint.referencedTable = def.definition.reference_definition.table;\n          constraint.referencedColumns = def.definition.reference_definition.column?.map((col: any) => col.column) || [];\n          constraint.onDelete = def.definition.reference_definition.on_delete;\n          constraint.onUpdate = def.definition.reference_definition.on_update;\n        }\n\n        constraints.push(constraint);\n      }\n    }\n\n    return constraints;\n  }\n\n  /**\n   * Map AST constraint type to our enum\n   */\n  private mapConstraintType(constraintType: string): ConstraintDefinition['type'] {\n    switch (constraintType?.toLowerCase()) {\n      case 'primary key': return 'PRIMARY_KEY';\n      case 'foreign key': return 'FOREIGN_KEY';\n      case 'unique': return 'UNIQUE';\n      case 'check': return 'CHECK';\n      default: return 'CHECK';\n    }\n  }\n\n  /**\n   * Extract table dependencies (foreign keys, references)\n   */\n  private extractTableDependencies(ast: any, tableName: string): TableDependency[] {\n    const dependencies: TableDependency[] = [];\n\n    if (ast.create_definitions) {\n      for (const def of ast.create_definitions) {\n        if (def.resource === 'constraint' && def.constraint_type === 'FOREIGN KEY') {\n          const refDef = def.definition?.reference_definition;\n          if (refDef) {\n            dependencies.push({\n              sourceTable: tableName,\n              targetTable: refDef.table,\n              type: 'FOREIGN_KEY',\n              columns: def.definition?.column?.map((col: any) => col.column) || [],\n              referencedColumns: refDef.column?.map((col: any) => col.column) || []\n            });\n          }\n        }\n      }\n    }\n\n    return dependencies;\n  }\n\n  /**\n   * Extract index definition from CREATE INDEX AST\n   */\n  private extractIndexDefinition(ast: any, tableName: string): IndexDefinition | null {\n    if (!ast.index || !ast.on) return null;\n\n    return {\n      name: ast.index,\n      columns: ast.definition?.map((col: any) => col.column) || [],\n      unique: ast.unique === true,\n      type: ast.using || 'btree',\n      tableName: ast.table || tableName,\n      concurrent: ast.options?.includes('CONCURRENTLY') || false\n    };\n  }\n\n  /**\n   * Identify dependencies between operations\n   */\n  private identifyOperationDependencies(analyses: SqlOperationAnalysis[]): OperationDependency[] {\n    const dependencies: OperationDependency[] = [];\n\n    for (let i = 0; i < analyses.length; i++) {\n      const current = analyses[i];\n      const dependsOn: SqlOperationAnalysis[] = [];\n\n      // Check for table creation dependencies\n      if (current.operation.type === 'ALTER_TABLE' || current.operation.type === 'CREATE_INDEX') {\n        const createTableOp = analyses.find(a => \n          a.operation.type === 'CREATE_TABLE' && \n          a.operation.tableName === current.operation.tableName\n        );\n        if (createTableOp) {\n          dependsOn.push(createTableOp);\n        }\n      }\n\n      // Check for foreign key dependencies\n      for (const dep of current.dependencies) {\n        if (dep.type === 'FOREIGN_KEY') {\n          const targetTableOp = analyses.find(a => \n            a.operation.type === 'CREATE_TABLE' && \n            a.operation.tableName === dep.targetTable\n          );\n          if (targetTableOp) {\n            dependsOn.push(targetTableOp);\n          }\n        }\n      }\n\n      if (dependsOn.length > 0) {\n        dependencies.push({\n          operation: current.operation,\n          dependsOn: dependsOn.map(d => d.operation),\n          dependencyType: 'TABLE_CREATION',\n          reason: `Operation depends on table creation: ${dependsOn.map(d => d.operation.tableName).join(', ')}`\n        });\n      }\n    }\n\n    return dependencies;\n  }\n\n  /**\n   * Calculate total complexity of all operations\n   */\n  private calculateTotalComplexity(analyses: SqlOperationAnalysis[]): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {\n    const complexityScores = { LOW: 1, MEDIUM: 2, HIGH: 3, CRITICAL: 4 };\n    const totalScore = analyses.reduce((sum, analysis) => sum + complexityScores[analysis.complexity], 0);\n    const avgScore = totalScore / analyses.length;\n\n    if (avgScore >= 3.5) return 'CRITICAL';\n    if (avgScore >= 2.5) return 'HIGH';\n    if (avgScore >= 1.5) return 'MEDIUM';\n    return 'LOW';\n  }\n\n  /**\n   * Identify risk factors in the migration\n   */\n  private identifyRiskFactors(analyses: SqlOperationAnalysis[]): string[] {\n    const risks: string[] = [];\n\n    const destructiveOps = analyses.filter(a => a.operation.metadata.isDestructive);\n    if (destructiveOps.length > 0) {\n      risks.push(`${destructiveOps.length} destructive operations that may cause data loss`);\n    }\n\n    const blockingOps = analyses.filter(a => a.operation.metadata.isBlocking);\n    if (blockingOps.length > 0) {\n      risks.push(`${blockingOps.length} blocking operations that may cause downtime`);\n    }\n\n    const criticalOps = analyses.filter(a => a.complexity === 'CRITICAL');\n    if (criticalOps.length > 0) {\n      risks.push(`${criticalOps.length} critical complexity operations requiring careful monitoring`);\n    }\n\n    const longRunningOps = analyses.filter(a => a.estimatedExecutionTime > 30000);\n    if (longRunningOps.length > 0) {\n      risks.push(`${longRunningOps.length} long-running operations (>30 seconds)`);\n    }\n\n    return risks;\n  }\n\n  /**\n   * Generate recommendations based on analysis\n   */\n  private generateRecommendations(analyses: SqlOperationAnalysis[], dependencies: OperationDependency[]): string[] {\n    const recommendations: string[] = [];\n\n    // Recommend concurrent index creation\n    const indexOps = analyses.filter(a => a.operation.type === 'CREATE_INDEX');\n    if (indexOps.length > 0) {\n      recommendations.push('Use CONCURRENT index creation to avoid blocking other operations');\n    }\n\n    // Recommend batching for large operations\n    const complexOps = analyses.filter(a => a.complexity === 'HIGH' || a.complexity === 'CRITICAL');\n    if (complexOps.length > 3) {\n      recommendations.push('Consider batching complex operations across multiple migration steps');\n    }\n\n    // Recommend maintenance window for blocking operations\n    const blockingOps = analyses.filter(a => a.operation.metadata.isBlocking);\n    if (blockingOps.length > 0) {\n      recommendations.push('Schedule blocking operations during maintenance windows');\n    }\n\n    // Recommend backup before destructive operations\n    const destructiveOps = analyses.filter(a => a.operation.metadata.isDestructive);\n    if (destructiveOps.length > 0) {\n      recommendations.push('Create database backup before executing destructive operations');\n    }\n\n    // Recommend dependency ordering\n    if (dependencies.length > 0) {\n      recommendations.push('Execute operations in dependency order to avoid failures');\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Estimate CREATE TABLE execution time\n   */\n  private estimateCreateTableTime(columnCount: number, constraintCount: number): number {\n    const baseTime = 500; // Base 0.5 seconds\n    const columnTime = columnCount * 50; // 50ms per column\n    const constraintTime = constraintCount * 200; // 200ms per constraint\n    return baseTime + columnTime + constraintTime;\n  }\n\n  /**\n   * Estimate generic operation execution time\n   */\n  private estimateGenericOperationTime(operation: ParsedSqlOperation): number {\n    switch (operation.metadata.estimatedDuration) {\n      case 'fast': return 500;\n      case 'medium': return 2000;\n      case 'slow': return 10000;\n      default: return 1000;\n    }\n  }\n} ","import * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { SqlParser, type ParsedSqlOperation } from './sql-parser.js';\n\n/**\n * Migration file types supported\n */\nexport enum MigrationType {\n  PRISMA = 'PRISMA',\n  DRIZZLE = 'DRIZZLE',\n  TYPEORM = 'TYPEORM',\n  PLAIN_SQL = 'PLAIN_SQL'\n}\n\n/**\n * Parsed migration file result\n */\nexport interface ParsedMigration {\n  filePath: string;\n  type: MigrationType;\n  name: string;\n  timestamp?: Date;\n  upOperations: ParsedSqlOperation[];\n  downOperations: ParsedSqlOperation[];\n  metadata: {\n    ormVersion?: string;\n    database: 'postgresql' | 'mysql' | 'sqlite';\n    hasUpMigration: boolean;\n    hasDownMigration: boolean;\n    totalOperations: number;\n    destructiveOperations: number;\n    blockingOperations: number;\n  };\n  errors: string[];\n  warnings: string[];\n}\n\n/**\n * Migration parsing result for multiple files\n */\nexport interface MigrationParseResult {\n  migrations: ParsedMigration[];\n  totalMigrations: number;\n  errors: string[];\n  warnings: string[];\n  summary: {\n    byType: Record<MigrationType, number>;\n    totalOperations: number;\n    destructiveOperations: number;\n    blockingOperations: number;\n  };\n}\n\n/**\n * Migration Parser for different ORM formats\n */\nexport class MigrationParser {\n  private sqlParser: SqlParser;\n\n  constructor() {\n    this.sqlParser = new SqlParser();\n  }\n\n  /**\n   * Parse a single migration file\n   */\n  public async parseMigrationFile(filePath: string, type?: MigrationType): Promise<ParsedMigration> {\n    const content = await fs.readFile(filePath, 'utf-8');\n    const detectedType = type || this.detectMigrationType(filePath, content);\n    \n    switch (detectedType) {\n      case MigrationType.PRISMA:\n        return this.parsePrismaMigration(filePath, content);\n      case MigrationType.DRIZZLE:\n        return this.parseDrizzleMigration(filePath, content);\n      case MigrationType.TYPEORM:\n        return this.parseTypeOrmMigration(filePath, content);\n      case MigrationType.PLAIN_SQL:\n        return this.parsePlainSqlMigration(filePath, content);\n      default:\n        throw new Error(`Unsupported migration type: ${detectedType}`);\n    }\n  }\n\n  /**\n   * Parse multiple migration files from a directory\n   */\n  public async parseMigrationDirectory(dirPath: string): Promise<MigrationParseResult> {\n    const files = await this.findMigrationFiles(dirPath);\n    const migrations: ParsedMigration[] = [];\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    for (const file of files) {\n      try {\n        const migration = await this.parseMigrationFile(file);\n        migrations.push(migration);\n        errors.push(...migration.errors);\n        warnings.push(...migration.warnings);\n      } catch (error) {\n        errors.push(`Failed to parse ${file}: ${error}`);\n      }\n    }\n\n    const summary = this.calculateSummary(migrations);\n\n    return {\n      migrations,\n      totalMigrations: migrations.length,\n      errors,\n      warnings,\n      summary\n    };\n  }\n\n  /**\n   * Detect migration type from file path and content\n   */\n  private detectMigrationType(filePath: string, content: string): MigrationType {\n    const fileName = path.basename(filePath);\n    const extension = path.extname(filePath);\n\n    // Check for Prisma migration (usually in prisma/migrations/)\n    if (filePath.includes('prisma/migrations') || fileName === 'migration.sql') {\n      return MigrationType.PRISMA;\n    }\n\n    // Check for Drizzle migration\n    if (extension === '.ts' && (\n      content.includes('import { sql }') ||\n      content.includes('drizzle-orm') ||\n      fileName.includes('drizzle')\n    )) {\n      return MigrationType.DRIZZLE;\n    }\n\n    // Check for TypeORM migration\n    if (extension === '.ts' && (\n      content.includes('import { MigrationInterface') ||\n      content.includes('QueryRunner') ||\n      fileName.match(/^\\d{13}-.*\\.ts$/)\n    )) {\n      return MigrationType.TYPEORM;\n    }\n\n    // Default to plain SQL\n    if (extension === '.sql') {\n      return MigrationType.PLAIN_SQL;\n    }\n\n    // If TypeScript but couldn't determine, try to guess from content\n    if (extension === '.ts') {\n      return MigrationType.TYPEORM; // Default for TS files\n    }\n\n    return MigrationType.PLAIN_SQL;\n  }\n\n  /**\n   * Parse Prisma migration file\n   */\n  private async parsePrismaMigration(filePath: string, content: string): Promise<ParsedMigration> {\n    const fileName = path.basename(filePath);\n    const timestamp = this.extractTimestampFromPrismaFile(filePath);\n    \n    // Prisma migrations are usually just SQL files\n    const sqlStatements = this.extractSqlStatements(content);\n    const database = this.detectDatabaseFromSql(content);\n    \n    const parseResult = this.sqlParser.parseMultipleSql(sqlStatements, database);\n\n    return {\n      filePath,\n      type: MigrationType.PRISMA,\n      name: fileName,\n      timestamp,\n      upOperations: parseResult.operations,\n      downOperations: [], // Prisma doesn't typically have down migrations\n      metadata: {\n        database,\n        hasUpMigration: parseResult.operations.length > 0,\n        hasDownMigration: false,\n        totalOperations: parseResult.operations.length,\n        destructiveOperations: parseResult.destructiveOperations,\n        blockingOperations: parseResult.blockingOperations\n      },\n      errors: parseResult.errors,\n      warnings: parseResult.warnings\n    };\n  }\n\n  /**\n   * Parse Drizzle migration file\n   */\n  private async parseDrizzleMigration(filePath: string, content: string): Promise<ParsedMigration> {\n    const fileName = path.basename(filePath, '.ts');\n    const timestamp = this.extractTimestampFromDrizzleFile(fileName);\n\n    // Extract SQL from Drizzle TypeScript file\n    const sqlStatements = this.extractSqlFromDrizzleTs(content);\n    const database = this.detectDatabaseFromContent(content);\n    \n    const parseResult = this.sqlParser.parseMultipleSql(sqlStatements, database);\n\n    return {\n      filePath,\n      type: MigrationType.DRIZZLE,\n      name: fileName,\n      timestamp,\n      upOperations: parseResult.operations,\n      downOperations: [], // Drizzle typically doesn't have down migrations in the same file\n      metadata: {\n        database,\n        hasUpMigration: parseResult.operations.length > 0,\n        hasDownMigration: false,\n        totalOperations: parseResult.operations.length,\n        destructiveOperations: parseResult.destructiveOperations,\n        blockingOperations: parseResult.blockingOperations\n      },\n      errors: parseResult.errors,\n      warnings: parseResult.warnings\n    };\n  }\n\n  /**\n   * Parse TypeORM migration file\n   */\n  private async parseTypeOrmMigration(filePath: string, content: string): Promise<ParsedMigration> {\n    const fileName = path.basename(filePath, '.ts');\n    const timestamp = this.extractTimestampFromTypeOrmFile(fileName);\n\n    // Extract SQL from up() and down() methods\n    const upSql = this.extractSqlFromTypeOrmMethod(content, 'up');\n    const downSql = this.extractSqlFromTypeOrmMethod(content, 'down');\n    const database = this.detectDatabaseFromContent(content);\n\n    const upParseResult = this.sqlParser.parseMultipleSql(upSql, database);\n    const downParseResult = this.sqlParser.parseMultipleSql(downSql, database);\n\n    return {\n      filePath,\n      type: MigrationType.TYPEORM,\n      name: fileName,\n      timestamp,\n      upOperations: upParseResult.operations,\n      downOperations: downParseResult.operations,\n      metadata: {\n        database,\n        hasUpMigration: upParseResult.operations.length > 0,\n        hasDownMigration: downParseResult.operations.length > 0,\n        totalOperations: upParseResult.operations.length + downParseResult.operations.length,\n        destructiveOperations: upParseResult.destructiveOperations + downParseResult.destructiveOperations,\n        blockingOperations: upParseResult.blockingOperations + downParseResult.blockingOperations\n      },\n      errors: [...upParseResult.errors, ...downParseResult.errors],\n      warnings: [...upParseResult.warnings, ...downParseResult.warnings]\n    };\n  }\n\n  /**\n   * Parse plain SQL migration file\n   */\n  private async parsePlainSqlMigration(filePath: string, content: string): Promise<ParsedMigration> {\n    const fileName = path.basename(filePath);\n    const timestamp = this.extractTimestampFromSqlFile(fileName);\n\n    // Split content by common delimiters for up/down migrations\n    const { upSql, downSql } = this.splitUpDownSql(content);\n    const database = this.detectDatabaseFromSql(content);\n\n    const upParseResult = this.sqlParser.parseMultipleSql(upSql, database);\n    const downParseResult = this.sqlParser.parseMultipleSql(downSql, database);\n\n    return {\n      filePath,\n      type: MigrationType.PLAIN_SQL,\n      name: fileName,\n      timestamp,\n      upOperations: upParseResult.operations,\n      downOperations: downParseResult.operations,\n      metadata: {\n        database,\n        hasUpMigration: upParseResult.operations.length > 0,\n        hasDownMigration: downParseResult.operations.length > 0,\n        totalOperations: upParseResult.operations.length + downParseResult.operations.length,\n        destructiveOperations: upParseResult.destructiveOperations + downParseResult.destructiveOperations,\n        blockingOperations: upParseResult.blockingOperations + downParseResult.blockingOperations\n      },\n      errors: [...upParseResult.errors, ...downParseResult.errors],\n      warnings: [...upParseResult.warnings, ...downParseResult.warnings]\n    };\n  }\n\n  /**\n   * Find all migration files in a directory\n   */\n  private async findMigrationFiles(dirPath: string): Promise<string[]> {\n    const files: string[] = [];\n    \n    try {\n      const entries = await fs.readdir(dirPath, { withFileTypes: true });\n      \n      for (const entry of entries) {\n        const fullPath = path.join(dirPath, entry.name);\n        \n        if (entry.isDirectory()) {\n          // Recursively search subdirectories\n          const subFiles = await this.findMigrationFiles(fullPath);\n          files.push(...subFiles);\n        } else if (entry.isFile() && this.isMigrationFile(entry.name)) {\n          files.push(fullPath);\n        }\n      }\n    } catch (error) {\n      // Directory might not exist, that's okay\n    }\n\n    return files.sort(); // Sort for consistent ordering\n  }\n\n  /**\n   * Check if a file is a migration file\n   */\n  private isMigrationFile(fileName: string): boolean {\n    const ext = path.extname(fileName);\n    \n    // Common migration file patterns\n    return (ext === '.sql' || ext === '.ts') && (\n      fileName.includes('migration') ||\n      fileName.match(/^\\d{4}-\\d{2}-\\d{2}/) || // Date format\n      fileName.match(/^\\d{10,}/) || // Timestamp format\n      fileName.includes('schema') ||\n      fileName === 'migration.sql'\n    );\n  }\n\n  /**\n   * Extract SQL statements from content\n   */\n  private extractSqlStatements(content: string): string[] {\n    return content\n      .split(';')\n      .map(stmt => stmt.trim())\n      .filter(stmt => stmt.length > 0 && !stmt.startsWith('--'));\n  }\n\n  /**\n   * Extract SQL from Drizzle TypeScript content\n   */\n  private extractSqlFromDrizzleTs(content: string): string[] {\n    const statements: string[] = [];\n    \n    // Look for sql`...` template literals\n    const sqlRegex = /sql`([^`]*)`/g;\n    let match;\n    \n    while ((match = sqlRegex.exec(content)) !== null) {\n      const sqlContent = match[1].trim();\n      if (sqlContent) {\n        statements.push(sqlContent);\n      }\n    }\n\n    // Look for direct SQL strings\n    const stringRegex = /[\"']([^\"']*(?:CREATE|ALTER|DROP|INSERT|UPDATE|DELETE)[^\"']*?)[\"']/gi;\n    while ((match = stringRegex.exec(content)) !== null) {\n      const sqlContent = match[1].trim();\n      if (sqlContent) {\n        statements.push(sqlContent);\n      }\n    }\n\n    return statements;\n  }\n\n  /**\n   * Extract SQL from TypeORM up() or down() method\n   */\n  private extractSqlFromTypeOrmMethod(content: string, method: 'up' | 'down'): string[] {\n    const statements: string[] = [];\n    \n    // Find the method definition\n    const methodRegex = new RegExp(`public\\\\s+async\\\\s+${method}\\\\s*\\\\([^)]*\\\\)\\\\s*:\\\\s*Promise<void>\\\\s*{([^}]*)}`, 's');\n    const match = methodRegex.exec(content);\n    \n    if (!match) return statements;\n    \n    const methodBody = match[1];\n    \n    // Look for queryRunner.query calls\n    const queryRegex = /queryRunner\\.query\\s*\\(\\s*[`\"']([^`\"']*)[`\"']/g;\n    let queryMatch;\n    \n    while ((queryMatch = queryRegex.exec(methodBody)) !== null) {\n      const sqlContent = queryMatch[1].trim();\n      if (sqlContent) {\n        statements.push(sqlContent);\n      }\n    }\n\n    return statements;\n  }\n\n  /**\n   * Split SQL content into up and down migrations\n   */\n  private splitUpDownSql(content: string): { upSql: string[]; downSql: string[] } {\n    // Look for common delimiters\n    const upDownDelimiters = [\n      /--\\s*UP\\s*\\n(.*?)--\\s*DOWN\\s*\\n(.*)/is,\n      /\\/\\*\\s*UP\\s*\\*\\/(.*?)\\/\\*\\s*DOWN\\s*\\*\\/(.*)/is,\n      /--\\s*@UP\\s*\\n(.*?)--\\s*@DOWN\\s*\\n(.*)/is\n    ];\n\n    for (const delimiter of upDownDelimiters) {\n      const match = content.match(delimiter);\n      if (match) {\n        return {\n          upSql: this.extractSqlStatements(match[1]),\n          downSql: this.extractSqlStatements(match[2])\n        };\n      }\n    }\n\n    // If no delimiter found, treat entire content as up SQL\n    return {\n      upSql: this.extractSqlStatements(content),\n      downSql: []\n    };\n  }\n\n  /**\n   * Detect database type from SQL content\n   */\n  private detectDatabaseFromSql(content: string): 'postgresql' | 'mysql' | 'sqlite' {\n    const upperContent = content.toUpperCase();\n    \n    if (upperContent.includes('SERIAL') || upperContent.includes('BIGSERIAL') || upperContent.includes('UUID')) {\n      return 'postgresql';\n    }\n    if (upperContent.includes('AUTO_INCREMENT') || upperContent.includes('TINYINT') || upperContent.includes('MEDIUMINT')) {\n      return 'mysql';\n    }\n    if (upperContent.includes('AUTOINCREMENT') || upperContent.includes('INTEGER PRIMARY KEY')) {\n      return 'sqlite';\n    }\n    \n    // Default to PostgreSQL\n    return 'postgresql';\n  }\n\n  /**\n   * Detect database type from TypeScript content\n   */\n  private detectDatabaseFromContent(content: string): 'postgresql' | 'mysql' | 'sqlite' {\n    if (content.includes('postgres') || content.includes('pg')) {\n      return 'postgresql';\n    }\n    if (content.includes('mysql') || content.includes('mariadb')) {\n      return 'mysql';\n    }\n    if (content.includes('sqlite')) {\n      return 'sqlite';\n    }\n    \n    // Default to PostgreSQL\n    return 'postgresql';\n  }\n\n  /**\n   * Extract timestamp from Prisma migration file path\n   */\n  private extractTimestampFromPrismaFile(filePath: string): Date | undefined {\n    // Prisma migrations are in format: 20231225120000_migration_name\n    const match = path.dirname(filePath).match(/(\\d{14})_/);\n    if (match) {\n      const timestamp = match[1];\n      return new Date(\n        parseInt(timestamp.substring(0, 4)), // year\n        parseInt(timestamp.substring(4, 6)) - 1, // month (0-based)\n        parseInt(timestamp.substring(6, 8)), // day\n        parseInt(timestamp.substring(8, 10)), // hour\n        parseInt(timestamp.substring(10, 12)), // minute\n        parseInt(timestamp.substring(12, 14)) // second\n      );\n    }\n    return undefined;\n  }\n\n  /**\n   * Extract timestamp from Drizzle migration file name\n   */\n  private extractTimestampFromDrizzleFile(fileName: string): Date | undefined {\n    // Drizzle migrations often have timestamps\n    const match = fileName.match(/(\\d{10,13})/);\n    if (match) {\n      const timestamp = parseInt(match[1]);\n      // If it's a 10-digit timestamp, it's in seconds; if 13-digit, it's in milliseconds\n      return new Date(timestamp < 10000000000 ? timestamp * 1000 : timestamp);\n    }\n    return undefined;\n  }\n\n  /**\n   * Extract timestamp from TypeORM migration file name\n   */\n  private extractTimestampFromTypeOrmFile(fileName: string): Date | undefined {\n    // TypeORM migrations are in format: 1640995200000-MigrationName\n    const match = fileName.match(/^(\\d{13})-/);\n    if (match) {\n      return new Date(parseInt(match[1]));\n    }\n    return undefined;\n  }\n\n  /**\n   * Extract timestamp from SQL file name\n   */\n  private extractTimestampFromSqlFile(fileName: string): Date | undefined {\n    // Try various timestamp formats\n    const patterns = [\n      /(\\d{4}-\\d{2}-\\d{2}[-_]\\d{2}-\\d{2}-\\d{2})/, // YYYY-MM-DD-HH-MM-SS\n      /(\\d{8}[-_]\\d{6})/, // YYYYMMDD-HHMMSS\n      /(\\d{10,13})/ // Unix timestamp\n    ];\n\n    for (const pattern of patterns) {\n      const match = fileName.match(pattern);\n      if (match) {\n        const timestamp = match[1];\n        if (timestamp.match(/^\\d{10,13}$/)) {\n          const ts = parseInt(timestamp);\n          return new Date(ts < 10000000000 ? ts * 1000 : ts);\n        } else {\n          // Try to parse as date string\n          try {\n            return new Date(timestamp.replace(/[-_]/g, match => match === '_' ? ' ' : '-'));\n          } catch {\n            continue;\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Calculate summary statistics\n   */\n  private calculateSummary(migrations: ParsedMigration[]): MigrationParseResult['summary'] {\n    const byType: Record<MigrationType, number> = {\n      [MigrationType.PRISMA]: 0,\n      [MigrationType.DRIZZLE]: 0,\n      [MigrationType.TYPEORM]: 0,\n      [MigrationType.PLAIN_SQL]: 0\n    };\n\n    let totalOperations = 0;\n    let destructiveOperations = 0;\n    let blockingOperations = 0;\n\n    for (const migration of migrations) {\n      byType[migration.type]++;\n      totalOperations += migration.metadata.totalOperations;\n      destructiveOperations += migration.metadata.destructiveOperations;\n      blockingOperations += migration.metadata.blockingOperations;\n    }\n\n    return {\n      byType,\n      totalOperations,\n      destructiveOperations,\n      blockingOperations\n    };\n  }\n} ","/**\n * SQL Risk Detection System\n * Identifies blocking operations, destructive operations, performance impacts, and downtime-causing operations\n */\n\nimport { DatabaseConnection, TableMetadata } from '@driftjs/core'\n\nexport interface RiskAssessment {\n  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'\n  riskScore: number // 0-100\n  riskCategories: RiskCategory[]\n  mitigationStrategies: string[]\n  warnings: string[]\n  blockers: string[]\n}\n\nexport interface RiskCategory {\n  type: 'BLOCKING' | 'DESTRUCTIVE' | 'PERFORMANCE' | 'CONSTRAINT' | 'DOWNTIME'\n  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'\n  description: string\n  affectedObjects: string[]\n  estimatedImpact: {\n    lockDuration?: number // seconds\n    downtime?: number // seconds\n    dataLoss?: boolean\n    rollbackDifficulty: 'EASY' | 'MEDIUM' | 'HARD' | 'IMPOSSIBLE'\n  }\n}\n\nexport class SQLRiskDetector {\n  constructor(private dbConnection?: DatabaseConnection) {}\n  \n  /**\n   * Analyze SQL statements for risks and generate comprehensive assessment\n   */\n  async analyzeSQL(sql: string, tableMetadata?: TableMetadata[]): Promise<RiskAssessment> {\n    const riskCategories: RiskCategory[] = []\n    const mitigationStrategies: string[] = []\n    const warnings: string[] = []\n    const blockers: string[] = []\n    \n    const statements = this.parseStatements(sql)\n    \n    for (const statement of statements) {\n      const statementRisks = await this.analyzeStatement(statement, tableMetadata)\n      riskCategories.push(...statementRisks.categories)\n      mitigationStrategies.push(...statementRisks.mitigations)\n      warnings.push(...statementRisks.warnings)\n      blockers.push(...statementRisks.blockers)\n    }\n    \n    const riskScore = this.calculateRiskScore(riskCategories)\n    const riskLevel = this.determineRiskLevel(riskScore)\n    \n    return {\n      riskLevel,\n      riskScore,\n      riskCategories,\n      mitigationStrategies: [...new Set(mitigationStrategies)],\n      warnings: [...new Set(warnings)],\n      blockers: [...new Set(blockers)]\n    }\n  }\n  \n  /**\n   * Parse SQL into individual statements\n   */\n  private parseStatements(sql: string): string[] {\n    // Simple statement separation - in production, use proper SQL parser\n    return sql\n      .split(';')\n      .map(stmt => stmt.trim())\n      .filter(stmt => stmt.length > 0)\n  }\n  \n  /**\n   * Analyze a single SQL statement for risks\n   */\n  private async analyzeStatement(statement: string, tableMetadata?: TableMetadata[]): Promise<{\n    categories: RiskCategory[]\n    mitigations: string[]\n    warnings: string[]\n    blockers: string[]\n  }> {\n    const categories: RiskCategory[] = []\n    const mitigations: string[] = []\n    const warnings: string[] = []\n    const blockers: string[] = []\n    \n    const statementLower = statement.toLowerCase().trim()\n    \n    // Detect blocking operations\n    const blockingRisks = this.detectBlockingOperations(statementLower, statement)\n    categories.push(...blockingRisks.categories)\n    mitigations.push(...blockingRisks.mitigations)\n    warnings.push(...blockingRisks.warnings)\n    \n    // Detect destructive operations\n    const destructiveRisks = this.detectDestructiveOperations(statementLower, statement)\n    categories.push(...destructiveRisks.categories)\n    mitigations.push(...destructiveRisks.mitigations)\n    warnings.push(...destructiveRisks.warnings)\n    \n    // Detect performance impacts\n    const performanceRisks = await this.detectPerformanceImpacts(statementLower, statement, tableMetadata)\n    categories.push(...performanceRisks.categories)\n    mitigations.push(...performanceRisks.mitigations)\n    warnings.push(...performanceRisks.warnings)\n    \n    // Detect constraint violations\n    const constraintRisks = this.detectConstraintViolations(statementLower, statement)\n    categories.push(...constraintRisks.categories)\n    mitigations.push(...constraintRisks.mitigations)\n    warnings.push(...constraintRisks.warnings)\n    \n    // Detect downtime-causing operations\n    const downtimeRisks = await this.detectDowntimeOperations(statementLower, statement, tableMetadata)\n    categories.push(...downtimeRisks.categories)\n    mitigations.push(...downtimeRisks.mitigations)\n    blockers.push(...downtimeRisks.blockers)\n    \n    return { categories, mitigations, warnings, blockers }\n  }\n  \n  /**\n   * Detect operations that cause table locks or block other operations\n   */\n  private detectBlockingOperations(statementLower: string, originalStatement: string): {\n    categories: RiskCategory[]\n    mitigations: string[]\n    warnings: string[]\n  } {\n    const categories: RiskCategory[] = []\n    const mitigations: string[] = []\n    const warnings: string[] = []\n    \n    // ALTER TABLE operations\n    if (statementLower.includes('alter table')) {\n      const tableName = this.extractTableName(statementLower, 'alter table')\n      \n      if (statementLower.includes('add column') && statementLower.includes('not null') && !statementLower.includes('default')) {\n        categories.push({\n          type: 'BLOCKING',\n          severity: 'HIGH',\n          description: 'Adding NOT NULL column without default requires table rewrite and exclusive lock',\n          affectedObjects: [tableName || 'unknown_table'],\n          estimatedImpact: {\n            lockDuration: 300, // 5 minutes estimated\n            rollbackDifficulty: 'MEDIUM'\n          }\n        })\n        mitigations.push('Add column as nullable first, then populate and add NOT NULL constraint')\n        mitigations.push('Add column with DEFAULT value to avoid table rewrite')\n      }\n      \n      if (statementLower.includes('drop column')) {\n        categories.push({\n          type: 'BLOCKING',\n          severity: 'MEDIUM',\n          description: 'Dropping column requires exclusive table lock',\n          affectedObjects: [tableName || 'unknown_table'],\n          estimatedImpact: {\n            lockDuration: 60, // 1 minute estimated\n            rollbackDifficulty: 'HARD'\n          }\n        })\n        mitigations.push('Consider renaming column first for gradual removal')\n      }\n      \n      if (statementLower.includes('add constraint') && statementLower.includes('foreign key')) {\n        categories.push({\n          type: 'BLOCKING',\n          severity: 'HIGH',\n          description: 'Adding foreign key constraint requires exclusive locks on both tables',\n          affectedObjects: [tableName || 'unknown_table'],\n          estimatedImpact: {\n            lockDuration: 180, // 3 minutes estimated\n            rollbackDifficulty: 'MEDIUM'\n          }\n        })\n        mitigations.push('Add constraint as NOT ENFORCED first, then validate separately')\n        warnings.push('Ensure referential integrity before adding constraint')\n      }\n      \n      if (statementLower.includes('add constraint') && statementLower.includes('unique')) {\n        categories.push({\n          type: 'BLOCKING',\n          severity: 'MEDIUM',\n          description: 'Adding unique constraint requires table scan and exclusive lock',\n          affectedObjects: [tableName || 'unknown_table'],\n          estimatedImpact: {\n            lockDuration: 120, // 2 minutes estimated\n            rollbackDifficulty: 'EASY'\n          }\n        })\n        mitigations.push('Check for duplicate data before adding constraint')\n        warnings.push('Unique constraint will fail if duplicate data exists')\n      }\n    }\n    \n    // CREATE INDEX without CONCURRENTLY\n    if (statementLower.includes('create index') && !statementLower.includes('concurrently')) {\n      const tableName = this.extractTableName(statementLower, 'on')\n      \n      categories.push({\n        type: 'BLOCKING',\n        severity: 'MEDIUM',\n        description: 'Creating index without CONCURRENTLY blocks table writes',\n        affectedObjects: [tableName || 'unknown_table'],\n        estimatedImpact: {\n          lockDuration: 120, // 2 minutes estimated\n          rollbackDifficulty: 'EASY'\n        }\n      })\n      \n      if (this.dbConnection?.type === 'postgresql') {\n        mitigations.push('Use CREATE INDEX CONCURRENTLY to avoid blocking writes')\n      }\n      warnings.push('Index creation time depends on table size')\n    }\n    \n    return { categories, mitigations, warnings }\n  }\n  \n  /**\n   * Detect operations that can cause data loss\n   */\n  private detectDestructiveOperations(statementLower: string, originalStatement: string): {\n    categories: RiskCategory[]\n    mitigations: string[]\n    warnings: string[]\n  } {\n    const categories: RiskCategory[] = []\n    const mitigations: string[] = []\n    const warnings: string[] = []\n    \n    // DROP operations\n    if (statementLower.includes('drop table')) {\n      const tableName = this.extractTableName(statementLower, 'drop table')\n      categories.push({\n        type: 'DESTRUCTIVE',\n        severity: 'CRITICAL',\n        description: 'Dropping table will permanently delete all data',\n        affectedObjects: [tableName || 'unknown_table'],\n        estimatedImpact: {\n          dataLoss: true,\n          rollbackDifficulty: 'IMPOSSIBLE'\n        }\n      })\n      mitigations.push('Create backup before dropping table')\n      mitigations.push('Consider renaming table instead of dropping')\n      warnings.push('Data will be permanently lost')\n    }\n    \n    if (statementLower.includes('drop column')) {\n      const tableName = this.extractTableName(statementLower, 'alter table')\n      categories.push({\n        type: 'DESTRUCTIVE',\n        severity: 'HIGH',\n        description: 'Dropping column will permanently delete column data',\n        affectedObjects: [tableName || 'unknown_table'],\n        estimatedImpact: {\n          dataLoss: true,\n          rollbackDifficulty: 'IMPOSSIBLE'\n        }\n      })\n      mitigations.push('Create backup of column data before dropping')\n      mitigations.push('Consider renaming column instead of dropping')\n      warnings.push('Column data will be permanently lost')\n    }\n    \n    if (statementLower.includes('truncate table')) {\n      const tableName = this.extractTableName(statementLower, 'truncate table')\n      categories.push({\n        type: 'DESTRUCTIVE',\n        severity: 'CRITICAL',\n        description: 'Truncating table will delete all rows',\n        affectedObjects: [tableName || 'unknown_table'],\n        estimatedImpact: {\n          dataLoss: true,\n          rollbackDifficulty: 'IMPOSSIBLE'\n        }\n      })\n      mitigations.push('Use DELETE with WHERE clause if you need selective removal')\n      warnings.push('All table data will be permanently lost')\n    }\n    \n    // Risky UPDATE/DELETE operations\n    if (statementLower.includes('delete from') && !statementLower.includes('where')) {\n      const tableName = this.extractTableName(statementLower, 'delete from')\n      categories.push({\n        type: 'DESTRUCTIVE',\n        severity: 'HIGH',\n        description: 'DELETE without WHERE clause will remove all rows',\n        affectedObjects: [tableName || 'unknown_table'],\n        estimatedImpact: {\n          dataLoss: true,\n          rollbackDifficulty: 'HARD'\n        }\n      })\n      warnings.push('DELETE without WHERE will remove all data')\n      mitigations.push('Add WHERE clause to limit deletion scope')\n    }\n    \n    if (statementLower.includes('update') && !statementLower.includes('where')) {\n      const tableName = this.extractTableName(statementLower, 'update')\n      categories.push({\n        type: 'DESTRUCTIVE',\n        severity: 'MEDIUM',\n        description: 'UPDATE without WHERE clause will modify all rows',\n        affectedObjects: [tableName || 'unknown_table'],\n        estimatedImpact: {\n          dataLoss: false,\n          rollbackDifficulty: 'HARD'\n        }\n      })\n      warnings.push('UPDATE without WHERE will modify all rows')\n      mitigations.push('Add WHERE clause to limit update scope')\n    }\n    \n    return { categories, mitigations, warnings }\n  }\n  \n  /**\n   * Detect operations with significant performance impact\n   */\n  private async detectPerformanceImpacts(statementLower: string, originalStatement: string, tableMetadata?: TableMetadata[]): Promise<{\n    categories: RiskCategory[]\n    mitigations: string[]\n    warnings: string[]\n  }> {\n    const categories: RiskCategory[] = []\n    const mitigations: string[] = []\n    const warnings: string[] = []\n    \n    if (!tableMetadata) return { categories, mitigations, warnings }\n    \n    // Large table operations\n    for (const table of tableMetadata) {\n      const tableName = table.name.toLowerCase()\n      \n      if (statementLower.includes(tableName)) {\n        // Operations on large tables\n        if (table.rowCount > 1000000) { // 1M+ rows\n          if (statementLower.includes('alter table')) {\n            categories.push({\n              type: 'PERFORMANCE',\n              severity: 'HIGH',\n              description: `Table ${table.name} has ${table.rowCount.toLocaleString()} rows - operation will be slow`,\n              affectedObjects: [table.name],\n              estimatedImpact: {\n                lockDuration: Math.floor(table.rowCount / 1000), // 1 second per 1000 rows\n                rollbackDifficulty: 'MEDIUM'\n              }\n            })\n            mitigations.push('Consider maintenance window for large table operations')\n            mitigations.push('Test operation on staging environment first')\n          }\n          \n          if (statementLower.includes('create index')) {\n            categories.push({\n              type: 'PERFORMANCE',\n              severity: 'MEDIUM',\n              description: `Index creation on large table ${table.name} will take significant time`,\n              affectedObjects: [table.name],\n              estimatedImpact: {\n                lockDuration: Math.floor(table.rowCount / 5000), // 1 second per 5000 rows\n                rollbackDifficulty: 'EASY'\n              }\n            })\n            mitigations.push('Use CONCURRENTLY option if available')\n            warnings.push('Monitor index creation progress')\n          }\n        }\n        \n        // Operations that require full table scan\n        if (statementLower.includes('add constraint') && statementLower.includes('check')) {\n          categories.push({\n            type: 'PERFORMANCE',\n            severity: 'MEDIUM',\n            description: `Adding CHECK constraint requires full table scan of ${table.name}`,\n            affectedObjects: [table.name],\n            estimatedImpact: {\n              lockDuration: Math.floor(table.rowCount / 10000), // 1 second per 10000 rows\n              rollbackDifficulty: 'EASY'\n            }\n          })\n          warnings.push('CHECK constraint validation requires scanning all rows')\n        }\n      }\n    }\n    \n    return { categories, mitigations, warnings }\n  }\n  \n  /**\n   * Detect potential constraint violations\n   */\n  private detectConstraintViolations(statementLower: string, originalStatement: string): {\n    categories: RiskCategory[]\n    mitigations: string[]\n    warnings: string[]\n  } {\n    const categories: RiskCategory[] = []\n    const mitigations: string[] = []\n    const warnings: string[] = []\n    \n    // NOT NULL constraints on existing tables\n    if (statementLower.includes('alter table') && statementLower.includes('not null')) {\n      const tableName = this.extractTableName(statementLower, 'alter table')\n      categories.push({\n        type: 'CONSTRAINT',\n        severity: 'HIGH',\n        description: 'Adding NOT NULL constraint may fail if existing NULL values exist',\n        affectedObjects: [tableName || 'unknown_table'],\n        estimatedImpact: {\n          rollbackDifficulty: 'EASY'\n        }\n      })\n      mitigations.push('Check for NULL values before adding NOT NULL constraint')\n      mitigations.push('Update NULL values with defaults before adding constraint')\n      warnings.push('Migration will fail if NULL values exist in column')\n    }\n    \n    // Unique constraints\n    if (statementLower.includes('add constraint') && statementLower.includes('unique')) {\n      const tableName = this.extractTableName(statementLower, 'alter table')\n      categories.push({\n        type: 'CONSTRAINT',\n        severity: 'MEDIUM',\n        description: 'Adding UNIQUE constraint may fail if duplicate values exist',\n        affectedObjects: [tableName || 'unknown_table'],\n        estimatedImpact: {\n          rollbackDifficulty: 'EASY'\n        }\n      })\n      mitigations.push('Check for duplicate values before adding UNIQUE constraint')\n      mitigations.push('Clean up duplicate data before adding constraint')\n      warnings.push('Migration will fail if duplicate values exist')\n    }\n    \n    return { categories, mitigations, warnings }\n  }\n  \n  /**\n   * Detect operations that cause downtime\n   */\n  private async detectDowntimeOperations(statementLower: string, originalStatement: string, tableMetadata?: TableMetadata[]): Promise<{\n    categories: RiskCategory[]\n    mitigations: string[]\n    blockers: string[]\n  }> {\n    const categories: RiskCategory[] = []\n    const mitigations: string[] = []\n    const blockers: string[] = []\n    \n    // Operations that require application downtime\n    if (statementLower.includes('rename table') || statementLower.includes('alter table') && statementLower.includes('rename to')) {\n      const tableName = this.extractTableName(statementLower, 'alter table')\n      categories.push({\n        type: 'DOWNTIME',\n        severity: 'HIGH',\n        description: 'Renaming table will break application references',\n        affectedObjects: [tableName || 'unknown_table'],\n        estimatedImpact: {\n          downtime: 60, // 1 minute estimated\n          rollbackDifficulty: 'MEDIUM'\n        }\n      })\n      mitigations.push('Coordinate with application deployment')\n      mitigations.push('Update application code to use new table name')\n      blockers.push('Application must be updated before/after table rename')\n    }\n    \n    // Column type changes that require conversion\n    if (statementLower.includes('alter column') && statementLower.includes('type')) {\n      const tableName = this.extractTableName(statementLower, 'alter table')\n      categories.push({\n        type: 'DOWNTIME',\n        severity: 'MEDIUM',\n        description: 'Changing column type may require data conversion and application updates',\n        affectedObjects: [tableName || 'unknown_table'],\n        estimatedImpact: {\n          downtime: 30, // 30 seconds estimated\n          rollbackDifficulty: 'HARD'\n        }\n      })\n      mitigations.push('Test data conversion on staging environment')\n      mitigations.push('Verify application compatibility with new data type')\n      warnings.push('Data conversion may fail if values are incompatible')\n    }\n    \n    return { categories, mitigations, blockers }\n  }\n  \n  /**\n   * Calculate overall risk score from individual risk categories\n   */\n  private calculateRiskScore(categories: RiskCategory[]): number {\n    if (categories.length === 0) return 0\n    \n    const severityWeights = {\n      'LOW': 10,\n      'MEDIUM': 25,\n      'HIGH': 50,\n      'CRITICAL': 100\n    }\n    \n    const typeWeights = {\n      'DESTRUCTIVE': 1.5,\n      'BLOCKING': 1.2,\n      'DOWNTIME': 1.3,\n      'CONSTRAINT': 1.0,\n      'PERFORMANCE': 0.8\n    }\n    \n    let totalScore = 0\n    let maxScore = 0\n    \n    for (const category of categories) {\n      const severityScore = severityWeights[category.severity]\n      const typeMultiplier = typeWeights[category.type]\n      const categoryScore = severityScore * typeMultiplier\n      \n      totalScore += categoryScore\n      maxScore = Math.max(maxScore, categoryScore)\n    }\n    \n    // Use a combination of average and maximum score\n    const avgScore = totalScore / categories.length\n    const finalScore = (avgScore * 0.6) + (maxScore * 0.4)\n    \n    return Math.min(100, Math.round(finalScore))\n  }\n  \n  /**\n   * Determine risk level from numeric score\n   */\n  private determineRiskLevel(score: number): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {\n    if (score >= 80) return 'CRITICAL'\n    if (score >= 60) return 'HIGH'\n    if (score >= 30) return 'MEDIUM'\n    return 'LOW'\n  }\n  \n  /**\n   * Extract table name from SQL statement\n   */\n  private extractTableName(statement: string, afterKeyword: string): string | null {\n    const regex = new RegExp(`${afterKeyword}\\\\s+([\\\\w\\\\-_\\\\.]+)`, 'i')\n    const match = statement.match(regex)\n    return match ? match[1] : null\n  }\n} ","/**\n * Enhancement Strategy Generator\n * Creates multi-step safe migration plans, pre-flight validation, and rollback strategies\n */\n\nimport { DatabaseConnection, TableMetadata } from '@driftjs/core'\nimport { RiskAssessment, SQLRiskDetector } from './risk-detector.js'\n\nexport interface EnhancementStrategy {\n  originalSQL: string\n  enhancedSteps: MigrationStep[]\n  rollbackStrategy: RollbackStrategy\n  preFlightChecks: PreFlightCheck[]\n  postMigrationValidation: ValidationStep[]\n  estimatedDuration: number // seconds\n  maintenanceWindow: MaintenanceWindow\n  dependencies: string[]\n}\n\nexport interface MigrationStep {\n  stepNumber: number\n  description: string\n  sql: string\n  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'\n  estimatedDuration: number // seconds\n  canRollback: boolean\n  dependencies: string[]\n  validationQueries: string[]\n  onFailure: 'CONTINUE' | 'STOP' | 'ROLLBACK'\n}\n\nexport interface RollbackStrategy {\n  canRollback: boolean\n  rollbackSteps: RollbackStep[]\n  dataBackupRequired: boolean\n  rollbackComplexity: 'SIMPLE' | 'MODERATE' | 'COMPLEX' | 'IMPOSSIBLE'\n  rollbackWindow: number // seconds\n}\n\nexport interface RollbackStep {\n  stepNumber: number\n  description: string\n  sql: string\n  condition?: string // When to execute this rollback step\n}\n\nexport interface PreFlightCheck {\n  checkName: string\n  description: string\n  query: string\n  expectedResult: 'EMPTY' | 'NOT_EMPTY' | 'SPECIFIC_VALUE' | 'CUSTOM'\n  expectedValue?: any\n  failureAction: 'WARN' | 'BLOCK' | 'PROMPT'\n  customValidation?: (result: any[]) => { success: boolean; message: string }\n}\n\nexport interface ValidationStep {\n  stepName: string\n  description: string\n  query: string\n  expectedCondition: string\n  isRequired: boolean\n}\n\nexport interface MaintenanceWindow {\n  recommended: boolean\n  minimumDuration: number // seconds\n  optimalDuration: number // seconds\n  considerations: string[]\n}\n\nexport class EnhancementStrategyGenerator {\n  private riskDetector: SQLRiskDetector\n  \n  constructor(private dbConnection: DatabaseConnection) {\n    this.riskDetector = new SQLRiskDetector(dbConnection)\n  }\n  \n  /**\n   * Generate comprehensive enhancement strategy for SQL migration\n   */\n  async generateStrategy(\n    originalSQL: string, \n    tableMetadata?: TableMetadata[],\n    options?: {\n      allowDataLoss?: boolean\n      preferSafety?: boolean\n      maxDowntime?: number // seconds\n    }\n  ): Promise<EnhancementStrategy> {\n    const riskAssessment = await this.riskDetector.analyzeSQL(originalSQL, tableMetadata)\n    \n    const enhancedSteps = await this.createEnhancedSteps(originalSQL, riskAssessment, tableMetadata, options)\n    const rollbackStrategy = this.createRollbackStrategy(enhancedSteps, riskAssessment)\n    const preFlightChecks = await this.createPreFlightChecks(originalSQL, tableMetadata)\n    const postMigrationValidation = this.createValidationSteps(originalSQL, tableMetadata)\n    const maintenanceWindow = this.calculateMaintenanceWindow(enhancedSteps, riskAssessment)\n    \n    const estimatedDuration = enhancedSteps.reduce((total, step) => total + step.estimatedDuration, 0)\n    const dependencies = this.extractDependencies(enhancedSteps)\n    \n    return {\n      originalSQL,\n      enhancedSteps,\n      rollbackStrategy,\n      preFlightChecks,\n      postMigrationValidation,\n      estimatedDuration,\n      maintenanceWindow,\n      dependencies\n    }\n  }\n  \n  /**\n   * Create enhanced migration steps with safety improvements\n   */\n  private async createEnhancedSteps(\n    originalSQL: string, \n    riskAssessment: RiskAssessment,\n    tableMetadata?: TableMetadata[],\n    options?: any\n  ): Promise<MigrationStep[]> {\n    const steps: MigrationStep[] = []\n    const statements = this.parseStatements(originalSQL)\n    \n    for (let i = 0; i < statements.length; i++) {\n      const statement = statements[i]\n      const statementLower = statement.toLowerCase().trim()\n      \n      // Generate enhanced steps based on operation type\n      if (statementLower.includes('alter table') && statementLower.includes('add column')) {\n        steps.push(...await this.enhanceAddColumn(statement, tableMetadata))\n      } else if (statementLower.includes('alter table') && statementLower.includes('drop column')) {\n        steps.push(...await this.enhanceDropColumn(statement, tableMetadata))\n      } else if (statementLower.includes('alter table') && statementLower.includes('add constraint')) {\n        steps.push(...await this.enhanceAddConstraint(statement, tableMetadata))\n      } else if (statementLower.includes('create index')) {\n        steps.push(...await this.enhanceCreateIndex(statement, tableMetadata))\n      } else if (statementLower.includes('drop table')) {\n        steps.push(...await this.enhanceDropTable(statement, tableMetadata))\n      } else {\n        // Default enhancement for other operations\n        steps.push(this.createDefaultStep(statement, i + 1))\n      }\n    }\n    \n    return steps\n  }\n  \n  /**\n   * Enhance ADD COLUMN operations for safety\n   */\n  private async enhanceAddColumn(statement: string, tableMetadata?: TableMetadata[]): Promise<MigrationStep[]> {\n    const steps: MigrationStep[] = []\n    const statementLower = statement.toLowerCase()\n    const tableName = this.extractTableName(statementLower, 'alter table')\n    \n    // If adding NOT NULL column without default, break into safer steps\n    if (statementLower.includes('not null') && !statementLower.includes('default')) {\n      const columnName = this.extractColumnName(statement)\n      const columnType = this.extractColumnType(statement)\n      \n      // Step 1: Add column as nullable\n      steps.push({\n        stepNumber: 1,\n        description: `Add column ${columnName} as nullable to table ${tableName}`,\n        sql: statement.replace(/not null/gi, '').trim(),\n        riskLevel: 'LOW',\n        estimatedDuration: 5,\n        canRollback: true,\n        dependencies: [],\n        validationQueries: [\n          `SELECT COUNT(*) FROM information_schema.columns WHERE table_name = '${tableName}' AND column_name = '${columnName}'`\n        ],\n        onFailure: 'STOP'\n      })\n      \n      // Step 2: Update NULL values with defaults (if needed)\n      steps.push({\n        stepNumber: 2,\n        description: `Update NULL values in ${columnName} with appropriate defaults`,\n        sql: `UPDATE ${tableName} SET ${columnName} = [SPECIFY_DEFAULT_VALUE] WHERE ${columnName} IS NULL;`,\n        riskLevel: 'MEDIUM',\n        estimatedDuration: 30,\n        canRollback: true,\n        dependencies: ['Step 1'],\n        validationQueries: [\n          `SELECT COUNT(*) FROM ${tableName} WHERE ${columnName} IS NULL`\n        ],\n        onFailure: 'ROLLBACK'\n      })\n      \n      // Step 3: Add NOT NULL constraint\n      steps.push({\n        stepNumber: 3,\n        description: `Add NOT NULL constraint to column ${columnName}`,\n        sql: `ALTER TABLE ${tableName} ALTER COLUMN ${columnName} SET NOT NULL;`,\n        riskLevel: 'MEDIUM',\n        estimatedDuration: 10,\n        canRollback: true,\n        dependencies: ['Step 2'],\n        validationQueries: [\n          `SELECT is_nullable FROM information_schema.columns WHERE table_name = '${tableName}' AND column_name = '${columnName}'`\n        ],\n        onFailure: 'ROLLBACK'\n      })\n    } else {\n      // Simple add column operation\n      steps.push({\n        stepNumber: 1,\n        description: `Add column to table ${tableName}`,\n        sql: statement,\n        riskLevel: 'LOW',\n        estimatedDuration: 5,\n        canRollback: true,\n        dependencies: [],\n        validationQueries: [\n          `SELECT COUNT(*) FROM information_schema.columns WHERE table_name = '${tableName}'`\n        ],\n        onFailure: 'STOP'\n      })\n    }\n    \n    return steps\n  }\n  \n  /**\n   * Enhance DROP COLUMN operations for safety\n   */\n  private async enhanceDropColumn(statement: string, tableMetadata?: TableMetadata[]): Promise<MigrationStep[]> {\n    const steps: MigrationStep[] = []\n    const statementLower = statement.toLowerCase()\n    const tableName = this.extractTableName(statementLower, 'alter table')\n    const columnName = this.extractColumnName(statement)\n    \n    // Step 1: Create backup of column data\n    steps.push({\n      stepNumber: 1,\n      description: `Create backup table with column data before dropping ${columnName}`,\n      sql: `CREATE TABLE ${tableName}_${columnName}_backup AS SELECT id, ${columnName} FROM ${tableName};`,\n      riskLevel: 'LOW',\n      estimatedDuration: 30,\n      canRollback: true,\n      dependencies: [],\n      validationQueries: [\n        `SELECT COUNT(*) FROM ${tableName}_${columnName}_backup`\n      ],\n      onFailure: 'STOP'\n    })\n    \n    // Step 2: Drop the column\n    steps.push({\n      stepNumber: 2,\n      description: `Drop column ${columnName} from table ${tableName}`,\n      sql: statement,\n      riskLevel: 'HIGH',\n      estimatedDuration: 60,\n      canRollback: false, // Dropping column is not easily reversible\n      dependencies: ['Step 1'],\n      validationQueries: [\n        `SELECT COUNT(*) FROM information_schema.columns WHERE table_name = '${tableName}' AND column_name = '${columnName}'`\n      ],\n      onFailure: 'STOP'\n    })\n    \n    return steps\n  }\n  \n  /**\n   * Enhance ADD CONSTRAINT operations for safety\n   */\n  private async enhanceAddConstraint(statement: string, tableMetadata?: TableMetadata[]): Promise<MigrationStep[]> {\n    const steps: MigrationStep[] = []\n    const statementLower = statement.toLowerCase()\n    const tableName = this.extractTableName(statementLower, 'alter table')\n    \n    if (statementLower.includes('foreign key')) {\n      // Step 1: Validate referential integrity\n      steps.push({\n        stepNumber: 1,\n        description: `Validate referential integrity before adding foreign key constraint`,\n        sql: `-- Custom validation query will be generated based on constraint details`,\n        riskLevel: 'MEDIUM',\n        estimatedDuration: 60,\n        canRollback: true,\n        dependencies: [],\n        validationQueries: [\n          `-- Validate no orphaned records exist`\n        ],\n        onFailure: 'STOP'\n      })\n      \n      // Step 2: Add constraint\n      steps.push({\n        stepNumber: 2,\n        description: `Add foreign key constraint to table ${tableName}`,\n        sql: statement,\n        riskLevel: 'HIGH',\n        estimatedDuration: 120,\n        canRollback: true,\n        dependencies: ['Step 1'],\n        validationQueries: [\n          `SELECT COUNT(*) FROM information_schema.table_constraints WHERE table_name = '${tableName}' AND constraint_type = 'FOREIGN KEY'`\n        ],\n        onFailure: 'ROLLBACK'\n      })\n    } else if (statementLower.includes('unique')) {\n      // Step 1: Check for duplicate values\n      steps.push({\n        stepNumber: 1,\n        description: `Check for duplicate values before adding unique constraint`,\n        sql: `-- Custom duplicate check query`,\n        riskLevel: 'MEDIUM',\n        estimatedDuration: 30,\n        canRollback: true,\n        dependencies: [],\n        validationQueries: [\n          `-- Check for duplicates in target columns`\n        ],\n        onFailure: 'STOP'\n      })\n      \n      // Step 2: Add unique constraint\n      steps.push({\n        stepNumber: 2,\n        description: `Add unique constraint to table ${tableName}`,\n        sql: statement,\n        riskLevel: 'MEDIUM',\n        estimatedDuration: 60,\n        canRollback: true,\n        dependencies: ['Step 1'],\n        validationQueries: [\n          `SELECT COUNT(*) FROM information_schema.table_constraints WHERE table_name = '${tableName}' AND constraint_type = 'UNIQUE'`\n        ],\n        onFailure: 'ROLLBACK'\n      })\n    } else {\n      // Default constraint addition\n      steps.push({\n        stepNumber: 1,\n        description: `Add constraint to table ${tableName}`,\n        sql: statement,\n        riskLevel: 'MEDIUM',\n        estimatedDuration: 30,\n        canRollback: true,\n        dependencies: [],\n        validationQueries: [],\n        onFailure: 'ROLLBACK'\n      })\n    }\n    \n    return steps\n  }\n  \n  /**\n   * Enhance CREATE INDEX operations for safety\n   */\n  private async enhanceCreateIndex(statement: string, tableMetadata?: TableMetadata[]): Promise<MigrationStep[]> {\n    const steps: MigrationStep[] = []\n    const statementLower = statement.toLowerCase()\n    const tableName = this.extractTableName(statementLower, 'on')\n    \n    // Check if CONCURRENTLY is already specified\n    if (this.dbConnection.type === 'postgresql' && !statementLower.includes('concurrently')) {\n      // Use CONCURRENTLY for PostgreSQL to avoid blocking\n      const enhancedSQL = statement.replace(/create index/i, 'CREATE INDEX CONCURRENTLY')\n      \n      steps.push({\n        stepNumber: 1,\n        description: `Create index concurrently on table ${tableName} to avoid blocking writes`,\n        sql: enhancedSQL,\n        riskLevel: 'LOW',\n        estimatedDuration: 300, // Longer but non-blocking\n        canRollback: true,\n        dependencies: [],\n        validationQueries: [\n          `SELECT COUNT(*) FROM pg_indexes WHERE tablename = '${tableName}'`\n        ],\n        onFailure: 'ROLLBACK'\n      })\n    } else {\n      // Default index creation\n      steps.push({\n        stepNumber: 1,\n        description: `Create index on table ${tableName}`,\n        sql: statement,\n        riskLevel: 'MEDIUM',\n        estimatedDuration: 180,\n        canRollback: true,\n        dependencies: [],\n        validationQueries: [],\n        onFailure: 'ROLLBACK'\n      })\n    }\n    \n    return steps\n  }\n  \n  /**\n   * Enhance DROP TABLE operations for safety\n   */\n  private async enhanceDropTable(statement: string, tableMetadata?: TableMetadata[]): Promise<MigrationStep[]> {\n    const steps: MigrationStep[] = []\n    const tableName = this.extractTableName(statement.toLowerCase(), 'drop table')\n    \n    // Step 1: Create full backup\n    steps.push({\n      stepNumber: 1,\n      description: `Create backup of table ${tableName} before dropping`,\n      sql: `CREATE TABLE ${tableName}_backup_${Date.now()} AS SELECT * FROM ${tableName};`,\n      riskLevel: 'LOW',\n      estimatedDuration: 120,\n      canRollback: true,\n      dependencies: [],\n      validationQueries: [\n        `SELECT COUNT(*) FROM ${tableName}_backup_${Date.now()}`\n      ],\n      onFailure: 'STOP'\n    })\n    \n    // Step 2: Drop the table\n    steps.push({\n      stepNumber: 2,\n      description: `Drop table ${tableName}`,\n      sql: statement,\n      riskLevel: 'CRITICAL',\n      estimatedDuration: 30,\n      canRollback: false, // Table drop is irreversible without backup\n      dependencies: ['Step 1'],\n      validationQueries: [\n        `SELECT COUNT(*) FROM information_schema.tables WHERE table_name = '${tableName}'`\n      ],\n      onFailure: 'STOP'\n    })\n    \n    return steps\n  }\n  \n  /**\n   * Create default migration step for unhandled operations\n   */\n  private createDefaultStep(statement: string, stepNumber: number): MigrationStep {\n    return {\n      stepNumber,\n      description: `Execute: ${statement.substring(0, 50)}${statement.length > 50 ? '...' : ''}`,\n      sql: statement,\n      riskLevel: 'MEDIUM',\n      estimatedDuration: 30,\n      canRollback: true,\n      dependencies: [],\n      validationQueries: [],\n      onFailure: 'STOP'\n    }\n  }\n  \n  /**\n   * Create rollback strategy for the migration\n   */\n  private createRollbackStrategy(steps: MigrationStep[], riskAssessment: RiskAssessment): RollbackStrategy {\n    const rollbackSteps: RollbackStep[] = []\n    let canRollback = true\n    let rollbackComplexity: 'SIMPLE' | 'MODERATE' | 'COMPLEX' | 'IMPOSSIBLE' = 'SIMPLE'\n    let dataBackupRequired = false\n    \n    // Generate rollback steps in reverse order\n    for (let i = steps.length - 1; i >= 0; i--) {\n      const step = steps[i]\n      \n      if (!step.canRollback) {\n        canRollback = false\n        rollbackComplexity = 'IMPOSSIBLE'\n        break\n      }\n      \n      if (step.riskLevel === 'HIGH' || step.riskLevel === 'CRITICAL') {\n        rollbackComplexity = 'COMPLEX'\n        dataBackupRequired = true\n      }\n      \n      // Generate appropriate rollback SQL\n      const rollbackSQL = this.generateRollbackSQL(step)\n      if (rollbackSQL) {\n        rollbackSteps.push({\n          stepNumber: rollbackSteps.length + 1,\n          description: `Rollback: ${step.description}`,\n          sql: rollbackSQL,\n          condition: `IF step ${step.stepNumber} was executed`\n        })\n      }\n    }\n    \n    const rollbackWindow = rollbackSteps.reduce((total, step) => total + 30, 0) // 30 seconds per rollback step\n    \n    return {\n      canRollback,\n      rollbackSteps,\n      dataBackupRequired,\n      rollbackComplexity,\n      rollbackWindow\n    }\n  }\n  \n  /**\n   * Generate appropriate rollback SQL for a migration step\n   */\n  private generateRollbackSQL(step: MigrationStep): string | null {\n    const sql = step.sql.toLowerCase().trim()\n    \n    if (sql.includes('alter table') && sql.includes('add column')) {\n      const tableName = this.extractTableName(sql, 'alter table')\n      const columnName = this.extractColumnName(step.sql)\n      return `ALTER TABLE ${tableName} DROP COLUMN ${columnName};`\n    }\n    \n    if (sql.includes('create index')) {\n      const indexName = this.extractIndexName(step.sql)\n      return `DROP INDEX ${indexName};`\n    }\n    \n    if (sql.includes('alter table') && sql.includes('add constraint')) {\n      const tableName = this.extractTableName(sql, 'alter table')\n      const constraintName = this.extractConstraintName(step.sql)\n      return `ALTER TABLE ${tableName} DROP CONSTRAINT ${constraintName};`\n    }\n    \n    // For operations that can't be easily rolled back\n    return `-- Manual rollback required for: ${step.description}`\n  }\n  \n  /**\n   * Create pre-flight validation checks\n   */\n  private async createPreFlightChecks(originalSQL: string, tableMetadata?: TableMetadata[]): Promise<PreFlightCheck[]> {\n    const checks: PreFlightCheck[] = []\n    const statementLower = originalSQL.toLowerCase()\n    \n    // Check for table existence\n    if (statementLower.includes('alter table')) {\n      const tableName = this.extractTableName(statementLower, 'alter table')\n      checks.push({\n        checkName: 'table_exists',\n        description: `Verify table ${tableName} exists`,\n        query: `SELECT COUNT(*) FROM information_schema.tables WHERE table_name = '${tableName}'`,\n        expectedResult: 'SPECIFIC_VALUE',\n        expectedValue: 1,\n        failureAction: 'BLOCK'\n      })\n    }\n    \n    // Check for sufficient disk space\n    checks.push({\n      checkName: 'disk_space',\n      description: 'Verify sufficient disk space for migration',\n      query: `-- Database-specific disk space query`,\n      expectedResult: 'CUSTOM',\n      failureAction: 'WARN',\n      customValidation: (result: any[]) => {\n        // Custom validation logic would go here\n        return { success: true, message: 'Sufficient disk space available' }\n      }\n    })\n    \n    // Check for active connections\n    checks.push({\n      checkName: 'active_connections',\n      description: 'Check for excessive active connections',\n      query: `-- Database-specific connection count query`,\n      expectedResult: 'CUSTOM',\n      failureAction: 'WARN',\n      customValidation: (result: any[]) => {\n        // Custom validation logic would go here\n        return { success: true, message: 'Connection count is acceptable' }\n      }\n    })\n    \n    return checks\n  }\n  \n  /**\n   * Create post-migration validation steps\n   */\n  private createValidationSteps(originalSQL: string, tableMetadata?: TableMetadata[]): ValidationStep[] {\n    const validations: ValidationStep[] = []\n    const statementLower = originalSQL.toLowerCase()\n    \n    if (statementLower.includes('alter table') && statementLower.includes('add column')) {\n      const tableName = this.extractTableName(statementLower, 'alter table')\n      const columnName = this.extractColumnName(originalSQL)\n      \n      validations.push({\n        stepName: 'column_added',\n        description: `Verify column ${columnName} was added to table ${tableName}`,\n        query: `SELECT COUNT(*) FROM information_schema.columns WHERE table_name = '${tableName}' AND column_name = '${columnName}'`,\n        expectedCondition: 'COUNT = 1',\n        isRequired: true\n      })\n    }\n    \n    if (statementLower.includes('create index')) {\n      const indexName = this.extractIndexName(originalSQL)\n      \n      validations.push({\n        stepName: 'index_created',\n        description: `Verify index ${indexName} was created`,\n        query: `-- Database-specific index existence query`,\n        expectedCondition: 'INDEX EXISTS',\n        isRequired: true\n      })\n    }\n    \n    return validations\n  }\n  \n  /**\n   * Calculate maintenance window requirements\n   */\n  private calculateMaintenanceWindow(steps: MigrationStep[], riskAssessment: RiskAssessment): MaintenanceWindow {\n    const totalDuration = steps.reduce((sum, step) => sum + step.estimatedDuration, 0)\n    const hasHighRisk = steps.some(step => step.riskLevel === 'HIGH' || step.riskLevel === 'CRITICAL')\n    const hasBlockingOperations = riskAssessment.riskCategories.some(cat => cat.type === 'BLOCKING')\n    \n    const recommended = hasHighRisk || hasBlockingOperations || totalDuration > 300 // 5 minutes\n    const minimumDuration = totalDuration\n    const optimalDuration = Math.ceil(totalDuration * 1.5) // 50% buffer\n    \n    const considerations: string[] = []\n    if (hasBlockingOperations) {\n      considerations.push('Migration includes blocking operations that will lock tables')\n    }\n    if (hasHighRisk) {\n      considerations.push('High-risk operations require careful monitoring')\n    }\n    if (totalDuration > 600) {\n      considerations.push('Long-running migration may impact performance')\n    }\n    \n    return {\n      recommended,\n      minimumDuration,\n      optimalDuration,\n      considerations\n    }\n  }\n  \n  /**\n   * Extract dependencies from migration steps\n   */\n  private extractDependencies(steps: MigrationStep[]): string[] {\n    const dependencies = new Set<string>()\n    \n    steps.forEach(step => {\n      step.dependencies.forEach(dep => dependencies.add(dep))\n    })\n    \n    return Array.from(dependencies)\n  }\n  \n  // Helper methods for SQL parsing\n  private parseStatements(sql: string): string[] {\n    return sql.split(';').map(stmt => stmt.trim()).filter(stmt => stmt.length > 0)\n  }\n  \n  private extractTableName(statement: string, afterKeyword: string): string | null {\n    const regex = new RegExp(`${afterKeyword}\\\\s+([\\\\w\\\\-_\\\\.]+)`, 'i')\n    const match = statement.match(regex)\n    return match ? match[1] : null\n  }\n  \n  private extractColumnName(statement: string): string | null {\n    const addColumnMatch = statement.match(/add\\s+column\\s+([^\\s]+)/i)\n    const dropColumnMatch = statement.match(/drop\\s+column\\s+([^\\s]+)/i)\n    return addColumnMatch?.[1] || dropColumnMatch?.[1] || null\n  }\n  \n  private extractColumnType(statement: string): string | null {\n    const match = statement.match(/add\\s+column\\s+\\w+\\s+([^\\s,]+)/i)\n    return match ? match[1] : null\n  }\n  \n  private extractIndexName(statement: string): string | null {\n    const match = statement.match(/create\\s+index\\s+([^\\s]+)/i)\n    return match ? match[1] : null\n  }\n  \n  private extractConstraintName(statement: string): string | null {\n    const match = statement.match(/constraint\\s+([^\\s]+)/i)\n    return match ? match[1] : null\n  }\n} ","import type { MigrationFile, EnhancedMigration } from '@driftjs/core'\nimport { SQLRiskDetector } from './risk-detector.js'\nimport { EnhancementStrategyGenerator } from './strategy-generator.js'\n\n/**\n * High-level engine that analyses risks and generates an enhanced migration plan.\n * NOTE: This is a minimal placeholder – detailed logic will be filled in Phase 2.\n */\nexport class EnhancementEngine {\n  private risk = new SQLRiskDetector()\n  private generator = new EnhancementStrategyGenerator({} as any)\n\n  /**\n   * Analyse a migration file and return an enhanced, production-safe version.\n   */\n  public async enhance(migration: MigrationFile): Promise<EnhancedMigration> {\n    // Concatenate SQL for risk analysis (basic approach)\n    const sql = migration.up\n    const riskReport = await this.risk.analyzeSQL(sql)\n\n    // Generate enhancement steps based on risk assessment\n    const strategy = await this.generator.generateStrategy(migration.up)\n\n    return {\n      original: migration,\n      enhanced: {\n        up: strategy.enhancedSteps.map(s => s.sql).join('\\n'),\n        down: strategy.rollbackStrategy.rollbackSteps.map(s => s.sql).join('\\n'),\n        preFlightChecks: strategy.preFlightChecks.map(c => c.query),\n        postMigrationValidation: strategy.postMigrationValidation.map(v => v.query),\n        rollbackStrategy: strategy.rollbackStrategy.rollbackSteps.map(s => s.sql)\n      },\n      estimatedDuration: strategy.estimatedDuration,\n    } as EnhancedMigration\n  }\n} "],"mappings":"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","names":["pkg","SqlOperationType","warnings","MigrationType","warnings","match","warnings"]}