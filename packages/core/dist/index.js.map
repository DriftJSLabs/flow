{"version":3,"sources":["../src/utils/file-utils.ts","../src/utils/async-utils.ts","../src/utils/validation.ts","../src/utils/config.ts"],"sourcesContent":["/**\n * File system utilities for DriftJS\n */\n\nimport fs from 'fs-extra'\nconst { readFile, writeFile, access, stat, readdir } = fs\nimport { join, resolve, relative, dirname } from 'path'\nimport { FilePath, Result } from '../types/common.js'\n\n/**\n * Check if a file or directory exists\n */\nexport async function exists(path: string): Promise<boolean> {\n  try {\n    await access(path)\n    return true\n  } catch {\n    return false\n  }\n}\n\n/**\n * Create a FilePath object with absolute and relative paths\n */\nexport async function createFilePath(path: string, basePath: string = process.cwd()): Promise<FilePath> {\n  const absolutePath = resolve(basePath, path)\n  const relativePath = relative(basePath, absolutePath)\n  const fileExists = await exists(absolutePath)\n  \n  return {\n    absolute: absolutePath,\n    relative: relativePath,\n    exists: fileExists\n  }\n}\n\n/**\n * Read file content with error handling\n */\nexport async function readFileContent(path: string): Promise<Result<string>> {\n  try {\n    const content = await readFile(path, 'utf-8')\n    return { success: true, data: content }\n  } catch (error) {\n    return { \n      success: false, \n      error: error instanceof Error ? error : new Error('Unknown error reading file')\n    }\n  }\n}\n\n/**\n * Write file content with error handling\n */\nexport async function writeFileContent(path: string, content: string): Promise<Result<void>> {\n  try {\n    await writeFile(path, content, 'utf-8')\n    return { success: true, data: undefined }\n  } catch (error) {\n    return { \n      success: false, \n      error: error instanceof Error ? error : new Error('Unknown error writing file')\n    }\n  }\n}\n\n/**\n * Get file statistics\n */\nexport async function getFileStats(path: string): Promise<Result<{ size: number; modified: Date; isDirectory: boolean }>> {\n  try {\n    const stats = await stat(path)\n    return {\n      success: true,\n      data: {\n        size: stats.size,\n        modified: stats.mtime,\n        isDirectory: stats.isDirectory()\n      }\n    }\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error : new Error('Unknown error getting file stats')\n    }\n  }\n}\n\n/**\n * Find files matching a pattern in a directory\n */\nexport async function findFiles(\n  directory: string,\n  pattern: RegExp,\n  recursive: boolean = true\n): Promise<string[]> {\n  const files: string[] = []\n  \n  try {\n    const items = await readdir(directory, { withFileTypes: true })\n    \n    for (const item of items) {\n      const fullPath = join(directory, item.name)\n      \n      if (item.isDirectory() && recursive) {\n        const subFiles = await findFiles(fullPath, pattern, recursive)\n        files.push(...subFiles)\n      } else if (item.isFile() && pattern.test(item.name)) {\n        files.push(fullPath)\n      }\n    }\n  } catch {\n    // Directory doesn't exist or can't be read\n  }\n  \n  return files\n}\n\n/**\n * Check if a directory contains any files matching a pattern\n */\nexport async function hasFilesMatching(directory: string, pattern: RegExp): Promise<boolean> {\n  const files = await findFiles(directory, pattern, false)\n  return files.length > 0\n}\n\n/**\n * Parse JSON file with error handling\n */\nexport async function readJsonFile<T = any>(path: string): Promise<Result<T>> {\n  const fileResult = await readFileContent(path)\n  \n  if (!fileResult.success) {\n    return fileResult\n  }\n  \n  try {\n    const data = JSON.parse(fileResult.data)\n    return { success: true, data }\n  } catch (error) {\n    return {\n      success: false,\n      error: new Error(`Invalid JSON in file ${path}: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n} ","/**\n * Async utilities for DriftJS\n */\n\nimport { Result } from '../types/common.js'\n\n/**\n * Retry a function with exponential backoff\n */\nexport async function retry<T>(\n  fn: () => Promise<T>,\n  options: {\n    maxAttempts: number\n    delay: number\n    backoff: number\n  } = { maxAttempts: 3, delay: 1000, backoff: 2 }\n): Promise<T> {\n  let lastError: Error\n  \n  for (let attempt = 1; attempt <= options.maxAttempts; attempt++) {\n    try {\n      return await fn()\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error('Unknown error')\n      \n      if (attempt === options.maxAttempts) {\n        throw lastError\n      }\n      \n      const delay = options.delay * Math.pow(options.backoff, attempt - 1)\n      await sleep(delay)\n    }\n  }\n  \n  throw lastError!\n}\n\n/**\n * Sleep for a specified number of milliseconds\n */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms))\n}\n\n/**\n * Timeout wrapper for promises\n */\nexport async function withTimeout<T>(\n  promise: Promise<T>,\n  timeoutMs: number,\n  timeoutMessage = 'Operation timed out'\n): Promise<T> {\n  const timeoutPromise = new Promise<never>((_, reject) => {\n    setTimeout(() => reject(new Error(timeoutMessage)), timeoutMs)\n  })\n  \n  return Promise.race([promise, timeoutPromise])\n}\n\n/**\n * Execute functions in parallel with concurrency limit\n */\nexport async function parallelLimit<T, R>(\n  items: T[],\n  fn: (item: T) => Promise<R>,\n  limit: number = 10\n): Promise<R[]> {\n  const results: R[] = []\n  const executing: Promise<void>[] = []\n  \n  for (const item of items) {\n    const promise = fn(item).then(result => {\n      results.push(result)\n    })\n    \n    executing.push(promise)\n    \n    if (executing.length >= limit) {\n      await Promise.race(executing)\n      executing.splice(executing.findIndex(p => p === promise), 1)\n    }\n  }\n  \n  await Promise.all(executing)\n  return results\n}\n\n/**\n * Convert callback-style function to promise\n */\nexport function promisify<T>(\n  fn: (callback: (error: Error | null, result?: T) => void) => void\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    fn((error, result) => {\n      if (error) {\n        reject(error)\n      } else {\n        resolve(result!)\n      }\n    })\n  })\n}\n\n/**\n * Safe async function wrapper that returns Result type\n */\nexport async function safeAsync<T>(\n  fn: () => Promise<T>\n): Promise<Result<T>> {\n  try {\n    const data = await fn()\n    return { success: true, data }\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error : new Error('Unknown error')\n    }\n  }\n} ","/**\n * Validation utilities for DriftJS\n */\n\nimport { DatabaseConfig, DatabaseType } from '../types/common.js'\n\n/**\n * Validate database configuration\n */\nexport function validateDatabaseConfig(config: Partial<DatabaseConfig>): { valid: boolean; errors: string[] } {\n  const errors: string[] = []\n  \n  if (!config.type) {\n    errors.push('Database type is required')\n  } else if (!isValidDatabaseType(config.type)) {\n    errors.push(`Invalid database type: ${config.type}`)\n  }\n  \n  if (!config.database) {\n    errors.push('Database name is required')\n  }\n  \n  if (config.url) {\n    if (!isValidConnectionString(config.url)) {\n      errors.push('Invalid database connection string')\n    }\n  } else {\n    if (!config.host) {\n      errors.push('Database host is required when not using connection string')\n    }\n    \n    if (config.port && (config.port < 1 || config.port > 65535)) {\n      errors.push('Invalid port number')\n    }\n  }\n  \n  return { valid: errors.length === 0, errors }\n}\n\n/**\n * Check if a string is a valid database type\n */\nexport function isValidDatabaseType(type: string): type is DatabaseType {\n  return ['postgresql', 'mysql', 'sqlite', 'mariadb'].includes(type)\n}\n\n/**\n * Basic validation for database connection strings\n */\nexport function isValidConnectionString(url: string): boolean {\n  try {\n    const parsed = new URL(url)\n    return ['postgresql:', 'postgres:', 'mysql:', 'sqlite:'].includes(parsed.protocol)\n  } catch {\n    return false\n  }\n}\n\n/**\n * Validate file path\n */\nexport function isValidFilePath(path: string): boolean {\n  if (!path || typeof path !== 'string') {\n    return false\n  }\n  \n  // Check for invalid characters\n  const invalidChars = /[<>:\"|?*]/\n  if (invalidChars.test(path)) {\n    return false\n  }\n  \n  return true\n}\n\n/**\n * Validate version string (semver-like)\n */\nexport function isValidVersion(version: string): boolean {\n  const semverRegex = /^\\d+\\.\\d+\\.\\d+(?:-[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*)?(?:\\+[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*)?$/\n  return semverRegex.test(version)\n}\n\n/**\n * Sanitize user input\n */\nexport function sanitizeInput(input: string): string {\n  return input\n    .replace(/[<>]/g, '') // Remove potential HTML tags\n    .replace(/[\\x00-\\x1f\\x7f]/g, '') // Remove control characters\n    .trim()\n}\n\n/**\n * Validate SQL identifier (table/column names)\n */\nexport function isValidSQLIdentifier(identifier: string): boolean {\n  if (!identifier || typeof identifier !== 'string') {\n    return false\n  }\n  \n  // SQL identifier rules: start with letter or underscore, followed by letters, digits, or underscores\n  const identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/\n  return identifierRegex.test(identifier) && identifier.length <= 63 // PostgreSQL limit\n} ","import fs from 'fs-extra'\nimport path from 'node:path'\nimport { FlowConfig } from '../types/config.js'\nimport { validateDatabaseConfig } from './validation.js'\n\n/**\n * Default file names that Drift Flow will look for when no --config flag is passed.\n */\nconst DEFAULT_CONFIG_FILES = [\n  'flow.config.json',\n  'flow.config.js',\n  'flow.config.cjs',\n  'flow.config.mjs',\n  'flow.config.ts',\n]\n\n/**\n * Load the first configuration file found in the current working directory hierarchy.\n * @param cwd Directory to start the search from (defaults to process.cwd())\n * @param explicitPath Optional explicit path passed by CLI flag\n */\nexport async function loadFlowConfig(\n  cwd: string = process.cwd(),\n  explicitPath?: string,\n): Promise<FlowConfig> {\n  let configPath: string | undefined = explicitPath\n\n  if (!configPath) {\n    configPath = await findConfigFile(cwd)\n    if (!configPath) {\n      throw new Error('Unable to locate flow.config file in current directory tree.')\n    }\n  }\n\n  const ext = path.extname(configPath)\n  let raw: unknown\n\n  if (ext === '.json') {\n    raw = await fs.readJSON(configPath)\n  } else if (ext === '.js' || ext === '.cjs' || ext === '.mjs') {\n    // eslint-disable-next-line import/no-dynamic-require, @typescript-eslint/no-var-requires\n    raw = await import(configPath)\n    raw = (raw as any).default ?? raw\n  } else if (ext === '.ts') {\n    throw new Error('Loading TypeScript config files is not yet supported. Please use JSON or JavaScript.')\n  } else {\n    throw new Error(`Unsupported config file extension: ${ext}`)\n  }\n\n  const validated = validateFlowConfig(raw)\n  if (!validated.valid) {\n    throw new Error(`Invalid flow.config: \\n${validated.errors.join('\\n')}`)\n  }\n\n  return validated.config!\n}\n\n/** Find the nearest config file walking up the directory tree */\nasync function findConfigFile(startDir: string): Promise<string | undefined> {\n  let dir = startDir\n  while (path.dirname(dir) !== dir) {\n    for (const file of DEFAULT_CONFIG_FILES) {\n      const candidate = path.join(dir, file)\n      if (await fs.pathExists(candidate)) {\n        return candidate\n      }\n    }\n    dir = path.dirname(dir)\n  }\n  return undefined\n}\n\nexport interface ValidationResult {\n  valid: boolean\n  errors: string[]\n  config?: FlowConfig\n}\n\n/**\n * Perform structural validation of FlowConfig instance.\n * We purposefully avoid pulling in a JSON-schema validator to keep deps light.\n */\nexport function validateFlowConfig(input: unknown): ValidationResult {\n  if (typeof input !== 'object' || input === null) {\n    return { valid: false, errors: ['Configuration must be an object'] }\n  }\n  const cfg = input as Partial<FlowConfig>\n  const errors: string[] = []\n\n  if (!cfg.environments || Object.keys(cfg.environments).length === 0) {\n    errors.push('`environments` section is required and cannot be empty')\n  }\n  if (!cfg.defaultEnvironment) {\n    errors.push('`defaultEnvironment` is required')\n  } else if (cfg.environments && !(cfg.defaultEnvironment in cfg.environments)) {\n    errors.push(`defaultEnvironment \\`${cfg.defaultEnvironment}\\` not found in environments section`)\n  }\n\n  // Validate each environment\n  if (cfg.environments) {\n    for (const [envName, envCfg] of Object.entries(cfg.environments)) {\n      if (!envCfg.databaseUrl) {\n        errors.push(`environment[${envName}].databaseUrl is required`)\n      }\n      if (envCfg.migrationsPath && typeof envCfg.migrationsPath !== 'string') {\n        errors.push(`environment[${envName}].migrationsPath must be a string`)\n      }\n      if (envCfg.migrationsPath) {\n        const absPath = path.isAbsolute(envCfg.migrationsPath)\n          ? envCfg.migrationsPath\n          : path.join(process.cwd(), envCfg.migrationsPath)\n        if (!(fs.existsSync(absPath))) {\n          errors.push(`environment[${envName}].migrationsPath '${envCfg.migrationsPath}' does not exist`)\n        }\n      }\n      // pattern toggles validation\n      if (envCfg.patterns) {\n        if (typeof envCfg.patterns !== 'object') {\n          errors.push(`environment[${envName}].patterns must be an object`)\n        }\n      }\n    }\n  }\n\n  // Validate safety thresholds\n  if (cfg.safety) {\n    if (cfg.safety.maxLockTimeMs && cfg.safety.maxLockTimeMs < 0) {\n      errors.push('safety.maxLockTimeMs must be positive')\n    }\n    if (cfg.safety.maxTableSizeMB && cfg.safety.maxTableSizeMB < 0) {\n      errors.push('safety.maxTableSizeMB must be positive')\n    }\n  }\n\n  // Validate database optimisation settings\n  if (cfg.database) {\n    for (const [name, dbCfg] of Object.entries(cfg.database)) {\n      const { valid, errors: dbErrors } = validateDatabaseConfig(dbCfg as any)\n      if (!valid) {\n        errors.push(...dbErrors.map((e) => `database[${name}]: ${e}`))\n      }\n    }\n  }\n\n  return { valid: errors.length === 0, errors, config: cfg as FlowConfig }\n} "],"mappings":"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","names":["path","resolve","path","fs","fs"]}