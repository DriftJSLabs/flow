{"version":3,"sources":["../src/index.ts","../package.json","../src/lib/prompts.ts","../src/commands/init.ts","../../../packages/analyzer/src/orm-detectors/base-detector.ts","../../../packages/analyzer/src/orm-detectors/prisma-detector.ts","../../../packages/analyzer/src/orm-detectors/drizzle-detector.ts","../../../packages/analyzer/src/orm-detectors/typeorm-detector.ts","../src/commands/sync.ts","../src/lib/config.ts","../src/commands/test.ts","../src/commands/apply.ts","../src/commands/back.ts"],"sourcesContent":["/**\n * @driftjs/flow - Enhanced database migration CLI tool\n * Core entry point with beautiful CLI interactions\n */\n\nimport { Command } from 'commander'\nimport { intro, outro, isCancel, cancel, log } from '@clack/prompts'\nimport { version } from '../package.json'\nimport { initCommand } from './commands/init.js'\nimport { syncCommand } from './commands/sync.js'\nimport { testCommand } from './commands/test.js'\nimport { applyCommand } from './commands/apply.js'\nimport { backCommand } from './commands/back.js'\n\nconst handleCommand = async (commandPromise: Promise<any>) => {\n  try {\n    await commandPromise;\n  } catch (error) {\n    if (isCancel(error)) {\n      cancel('Operation cancelled.');\n      process.exit(0);\n    }\n    log.error(error instanceof Error ? error.message : 'An unknown error occurred.');\n    process.exit(1);\n  }\n};\n\nconst program = new Command()\n\nprogram\n  .name('flow')\n  .description('Enhanced database migration CLI tool for production-safety')\n  .version(version, '-v, --version', 'Output the current version')\n  .option('-d, --debug', 'Enable verbose logging')\n  .option('-c, --config <path>', 'Path to flow.config.json', './flow.config.json')\n  .option('--dry-run', 'Show what would be done without executing')\n\n// flow init - Initialize flow configuration\nprogram\n  .command('init')\n  .description('Initialize flow configuration in current project')\n  .option('--project <path>', 'Path to the project directory')\n  .option('--env-name <name>', 'Name for the initial environment', 'development')\n  .option('--db-url <url>', 'Database connection string')\n  .option('--migrations-path <path>', 'Path to the migrations folder')\n  .option('-y, --yes', 'Skip interactive prompts and use default or provided values')\n  .action(async (options) => {\n    intro('üåä DriftJS Flow - Initialize')\n    await handleCommand(initCommand(options, program.opts() as any));\n    outro('‚úÖ Flow configuration initialized successfully!')\n  })\n\n// flow sync\nprogram\n  .command('sync')\n  .description('Detect ORM changes and create enhanced migration plan')\n  .option('--force', 'Force re-analysis of existing migrations')\n  .option('--orm <name>', 'Specify ORM (prisma, drizzle, typeorm, auto)', 'auto')\n  .option('--project <path>', 'Path to the project directory')\n  .option('-y, --yes', 'Skip interactive prompts and use default or provided values')\n  .action(async (options) => {\n    intro('üåä DriftJS Flow - Sync')\n    await handleCommand(syncCommand(options, program.opts() as any));\n    outro('‚úÖ Sync completed')\n  })\n\n// flow apply\nprogram\n  .command('apply')\n  .description('Apply pending migrations to the database')\n  .option('--migration <name>', 'Apply a specific migration by name')\n  .option('--target <name>', 'Apply migrations up to and including the target migration')\n  .option('--project <path>', 'Path to the project directory')\n  .option('-y, --yes', 'Skip interactive prompts and use default or provided values')\n  .action(async (options) => {\n    intro('üåä DriftJS Flow - Apply')\n    await handleCommand(applyCommand(options, program.opts() as any));\n    outro('‚úÖ Apply completed')\n  })\n\n// flow back\nprogram\n  .command('back')\n  .description('Rollback the latest migration batch')\n  .option('--steps <n>', 'Number of migrations to rollback', '1')\n  .option('--to <name>', 'Rollback to a specific migration (exclusive)')\n  .option('--project <path>', 'Path to the project directory')\n  .option('-y, --yes', 'Skip interactive prompts and use default or provided values')\n  .action(async (options) => {\n    intro('üåä DriftJS Flow - Rollback')\n    // Convert steps to number\n    if (options.steps) {\n      options.steps = parseInt(options.steps, 10)\n    }\n    await handleCommand(backCommand(options, program.opts() as any));\n    outro('‚úÖ Rollback completed')\n  })\n\n// flow test (internal)\nprogram\n  .command('test')\n  .description('Run internal diagnostics')\n  .option('--project <path>', 'Path to the project directory')\n  .action(testCommand as any)\n\n// Execute the CLI\nprogram.parse() ","{\n  \"name\": \"@driftjs/flow\",\n  \"version\": \"0.1.7\",\n  \"description\": \"The smart CLI for safe schema evolution. Flow wraps your ORM to automate zero-downtime migrations and prevent production risks.\",\n  \"main\": \"dist/index.js\",\n  \"type\": \"module\",\n  \"bin\": {\n    \"flow\": \"./dist/index.js\"\n  },\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"dev\": \"tsup --watch\",\n    \"check-types\": \"tsc --noEmit\",\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\"\n  },\n  \"keywords\": [\n    \"database\",\n    \"migration\",\n    \"orm\",\n    \"prisma\",\n    \"drizzle\",\n    \"typeorm\",\n    \"cli\",\n    \"production-safety\"\n  ],\n  \"author\": \"DriftJS Team\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"@clack/prompts\": \"^0.7.0\",\n    \"@driftjs/core\": \"workspace:*\",\n    \"@driftjs/enhancer\": \"workspace:*\",\n    \"@types/sqlite3\": \"^5.1.0\",\n    \"better-sqlite3\": \"^9.4.0\",\n    \"commander\": \"^12.0.0\",\n    \"diff\": \"^5.2.0\",\n    \"dotenv\": \"^16.4.5\",\n    \"execa\": \"^9.6.0\",\n    \"fs-extra\": \"^11.2.0\",\n    \"ms\": \"^2.1.3\",\n    \"mysql2\": \"^3.10.1\",\n    \"node-sql-parser\": \"^5.0.0\",\n    \"pg\": \"^8.12.0\",\n    \"picocolors\": \"^1.0.1\",\n    \"prompts\": \"^2.4.2\",\n    \"sqlite3\": \"^5.1.7\"\n  },\n  \"devDependencies\": {\n    \"@types/better-sqlite3\": \"^7.6.9\",\n    \"@types/diff\": \"^5.2.1\",\n    \"@types/fs-extra\": \"^11.0.4\",\n    \"@types/jest\": \"^29.5.0\",\n    \"@types/ms\": \"^0.7.34\",\n    \"@types/pg\": \"^8.11.0\",\n    \"jest\": \"^29.7.0\",\n    \"ts-jest\": \"^29.1.0\",\n    \"tsup\": \"^8.0.0\",\n    \"typescript\": \"^5.3.0\",\n    \"@types/bun\": \"latest\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  }\n}","/**\n * Reusable prompt components for beautiful CLI interactions\n */\n\nimport { confirm, select, multiselect, text, spinner, log } from '@clack/prompts'\nimport colors from 'picocolors'\n\nexport interface EnhancementOption {\n  value: string\n  label: string\n  hint?: string\n  danger?: boolean\n}\n\n/**\n * Confirmation prompt with enhanced styling\n */\nexport async function confirmAction(\n  message: string,\n  options: any = {}\n): Promise<boolean> {\n  return await confirm({\n    message: colors.cyan(message),\n    ...options\n  }) as boolean\n}\n\n/**\n * Selection prompt for single choice\n */\nexport async function selectOption<T extends string>(\n  message: string,\n  options: Array<{ value: T; label: string; hint?: string }>,\n  selectOptions: any = {}\n): Promise<T> {\n  return await select({\n    message: colors.cyan(message),\n    options: options.map(opt => ({\n      value: opt.value,\n      label: opt.label,\n      hint: opt.hint ? colors.dim(opt.hint) : undefined\n    })),\n    ...selectOptions\n  }) as T\n}\n\n/**\n * Multi-selection prompt for multiple choices\n */\nexport async function selectMultiple<T extends string>(\n  message: string,\n  options: Array<{ value: T; label: string; hint?: string; required?: boolean }>,\n  multiselectOptions: any = {}\n): Promise<T[]> {\n  return await multiselect({\n    message: colors.cyan(message),\n    options: options.map(opt => ({\n      value: opt.value,\n      label: opt.label,\n      hint: opt.hint ? colors.dim(opt.hint) : undefined,\n      required: opt.required\n    })),\n    ...multiselectOptions\n  }) as T[]\n}\n\n/**\n * Text input prompt with validation\n */\nexport async function textInput(\n  message: string,\n  options: any = {}\n): Promise<string> {\n  return await text({\n    message: colors.cyan(message),\n    ...options\n  }) as string\n}\n\n/**\n * Enhancement selection flow\n */\nexport async function selectEnhancements(\n  availableEnhancements: EnhancementOption[]\n): Promise<string[]> {\n  log.info(colors.blue('üîç Available migration enhancements:'))\n  \n  const options = availableEnhancements.map(enhancement => ({\n    value: enhancement.value,\n    label: enhancement.danger \n      ? colors.red(`‚ö†Ô∏è  ${enhancement.label}`)\n      : colors.green(`‚úÖ ${enhancement.label}`),\n    hint: enhancement.hint,\n    required: false\n  }))\n\n  return await selectMultiple(\n    'Select enhancements to apply:',\n    options,\n    {\n      required: false\n    }\n  )\n}\n\n/**\n * Database connection confirmation\n */\nexport async function confirmDatabaseConnection(\n  connectionString: string\n): Promise<boolean> {\n  log.info(colors.yellow('üîå Database connection details:'))\n  log.info(colors.dim(`   ${connectionString}`))\n  \n  return await confirmAction(\n    'Proceed with this database connection?',\n    {\n      initialValue: false\n    }\n  )\n}\n\n/**\n * Migration risk confirmation\n */\nexport async function confirmHighRiskOperation(\n  operationName: string,\n  risks: string[]\n): Promise<boolean> {\n  log.warn(colors.red(`‚ö†Ô∏è  HIGH RISK OPERATION: ${operationName}`))\n  \n  risks.forEach(risk => {\n    log.warn(colors.red(`   ‚Ä¢ ${risk}`))\n  })\n  \n  return await confirmAction(\n    colors.red('Do you understand the risks and want to proceed?'),\n    {\n      initialValue: false\n    }\n  )\n}\n\n/**\n * Progress spinner with custom styling\n */\nexport function createSpinner(message: string) {\n  const s = spinner()\n  s.start(colors.blue(`üåä ${message}`))\n  \n  return {\n    update: (newMessage: string) => s.message(colors.blue(`üåä ${newMessage}`)),\n    succeed: (message?: string) => s.stop(colors.green(`‚úÖ ${message || 'Complete'}`)),\n    fail: (message?: string) => s.stop(colors.red(`‚ùå ${message || 'Failed'}`)),\n    stop: () => s.stop()\n  }\n} ","/**\n * flow init - Initialize flow configuration\n */\n\nimport { createSpinner, textInput, confirmAction } from '../lib/prompts.js'\nimport { GlobalOptions } from '../lib/config.js'\nimport fsExtra from 'fs-extra'\nimport { resolve } from 'node:path'\nimport dotenv from 'dotenv'\nimport { PrismaDetector, DrizzleDetector, TypeORMDetector } from '@driftjs/analyzer'\n// @ts-ignore ‚Äì optional type import not strictly needed for compilation\n// import type { FlowConfig } from '@driftjs/core'\n\nexport interface InitOptions {\n  force?: boolean\n  envName?: string\n  dbUrl?: string\n  migrationsPath?: string\n  yes?: boolean\n  project?: string\n}\n\nasync function findDatabaseUrl(envName: string, projectPath: string): Promise<string> {\n  const candidateFiles: string[] = []\n  // 1) current directory .env\n  candidateFiles.push(resolve(projectPath, '.env'))\n  // 2) parent directories up to repo root\n  const parts = projectPath.split('/')\n  for (let i = parts.length - 1; i > 0; i--) {\n    candidateFiles.push(parts.slice(0, i + 1).join('/') + '/.env')\n  }\n  // 3) common monorepo locations (apps/*/.env and packages/*/.env)\n  const appsDir = resolve(projectPath, 'apps')\n  const pkgsDir = resolve(projectPath, 'packages')\n  if (await fsExtra.pathExists(appsDir)) {\n    const sub = await fsExtra.readdir(appsDir)\n    sub.forEach((s) => candidateFiles.push(resolve(appsDir, s, '.env')))\n  }\n  if (await fsExtra.pathExists(pkgsDir)) {\n    const sub = await fsExtra.readdir(pkgsDir)\n    sub.forEach((s) => candidateFiles.push(resolve(pkgsDir, s, '.env')))\n  }\n\n  for (const file of candidateFiles) {\n    if (await fsExtra.pathExists(file)) {\n      try {\n        const envVars = dotenv.parse(await fsExtra.readFile(file))\n        const v =\n          envVars.DATABASE_URL || envVars[`DATABASE_URL_${envName.toUpperCase()}`]\n        if (v) return v\n      } catch {}\n    }\n  }\n  return ''\n}\n\nasync function detectMigrationsDir(projectPath: string): Promise<string | null> {\n  const candidates = [\n    'migrations',\n    'db/migrations',\n    'drizzle/migrations',\n    'prisma/migrations',\n    'database/migrations'\n  ]\n  // Parse drizzle.config.* for out path\n  const drizzleConfigFiles = ['drizzle.config.ts', 'drizzle.config.js', 'drizzle.config.mjs', 'drizzle.config.cjs']\n  for (const f of drizzleConfigFiles) {\n    if (await fsExtra.pathExists(resolve(projectPath, f))) {\n      const content = await fsExtra.readFile(resolve(projectPath, f), 'utf8')\n      const match = content.match(/out\\s*:\\s*[\"'`](.+?)[\"'`]/)\n      if (match) {\n        candidates.unshift(match[1])\n      }\n    }\n  }\n  for (const rel of candidates) {\n    if (await fsExtra.pathExists(resolve(projectPath, rel))) return rel\n  }\n  return null\n}\n\nexport async function initCommand(options: InitOptions, globalOptions: GlobalOptions): Promise<void> {\n  const projectPath = resolve(options.project || process.cwd())\n  const spinner = createSpinner('Collecting project information')\n\n  let envName: string, databaseUrl: string, migrationsPath: string;\n\n  if (options.yes) {\n    // Non-interactive mode\n    envName = options.envName || 'development';\n    const detectedDb = await findDatabaseUrl(envName, projectPath);\n    databaseUrl = options.dbUrl || detectedDb;\n\n    if (!databaseUrl) {\n      spinner.fail('Database connection string is required. Please provide it with --db-url.');\n      throw new Error('FLOW_MISSING_DB_NON_INTERACTIVE');\n    }\n    \n    const detectedPath = await detectMigrationsDir(projectPath);\n    migrationsPath = options.migrationsPath || detectedPath || './migrations';\n\n  } else {\n    // Interactive mode\n    const envNameInput = await textInput('Environment name', {\n      placeholder: 'development',\n      defaultValue: 'development'\n    });\n    envName = envNameInput?.trim() || 'development';\n\n    const defaultDb = await findDatabaseUrl(envName, projectPath);\n    const dbPrompt = 'Database connection string (e.g. postgresql://user:pass@localhost:5432/db)';\n    const dbInput = await textInput(dbPrompt, {\n      placeholder: defaultDb || 'postgresql://user:pass@localhost:5432/db',\n      defaultValue: defaultDb\n    });\n    databaseUrl = (dbInput?.trim() || defaultDb).trim();\n\n    if (!databaseUrl) {\n      spinner.fail('Database connection string is required');\n      throw new Error('FLOW_MISSING_DB');\n    }\n\n    const detectedPath = (await detectMigrationsDir(projectPath)) || './migrations';\n    const migInput = await textInput('Path to migrations folder', {\n      placeholder: detectedPath,\n      defaultValue: detectedPath\n    });\n    migrationsPath = migInput?.trim() || detectedPath;\n\n    const proceed = await confirmAction('Generate configuration with these values?');\n    if (!proceed) {\n      spinner.fail('User cancelled');\n      return;\n    }\n  }\n\n  spinner.update('Generating flow.config')\n\n  // Detect ORM\n  const detectors = [\n    { name: 'prisma', detector: new PrismaDetector() },\n    { name: 'drizzle', detector: new DrizzleDetector() },\n    { name: 'typeorm', detector: new TypeORMDetector() }\n  ]\n  let detectedORM: string | null = null;\n  for (const { name, detector } of detectors) {\n    const result = await detector.detect(projectPath)\n    if (result.found) {\n      detectedORM = name\n      break\n    }\n  }\n\n  // Build config object\n  const config: any = {\n    version: '0.1.0',\n    defaultEnvironment: envName,\n    ...(detectedORM && { orm: detectedORM }),\n    environments: {\n      [envName]: {\n        db_connection_string: databaseUrl,\n        migrationsPath: migrationsPath\n      }\n    },\n    safety: {\n      maxTableSizeMB: 1024,\n      maxLockTimeMs: 300_000\n    }\n  }\n\n  const configPath = resolve(projectPath, globalOptions.config || 'flow.config.json')\n\n  if (await fsExtra.pathExists(configPath) && !options.yes && !(await confirmAction(`Overwrite existing ${configPath}?`))) {\n    spinner.fail('Init aborted ‚Äì config exists')\n    return\n  }\n\n  if (!globalOptions.dryRun) {\n    await fsExtra.writeFile(configPath, JSON.stringify(config, null, 2))\n    spinner.succeed(`Configuration written to ${configPath}`)\n  } else {\n    spinner.succeed('Dry run complete ‚Äì configuration would be:')\n    console.log(JSON.stringify(config, null, 2))\n  }\n\n  // --- NEW: ensure package.json has a \"flow\" script for easy execution\n  try {\n    const pkgPath = resolve(projectPath, 'package.json')\n    if (await fsExtra.pathExists(pkgPath)) {\n      // Dynamic import to avoid increasing cold start\n      const fsmod: any = await import('fs-extra')\n      const fsDyn = (fsmod.default ?? fsmod) as typeof fsExtra\n      const pkg = await fsDyn.readJson(pkgPath)\n      pkg.scripts = pkg.scripts || {}\n      if (!pkg.scripts.flow) {\n        pkg.scripts.flow = 'flow'\n        await fsDyn.writeJson(pkgPath, pkg, { spaces: 2 })\n        spinner.update('Added \"flow\" script to package.json')\n      }\n    }\n  } catch (err) {\n    // Non-fatal; emit warning but continue\n    console.warn('‚ö†Ô∏è  Could not update package.json:', err instanceof Error ? err.message : err)\n  }\n} ","/**\n * Base ORM detector with common functionality\n */\n\nimport { join } from 'path'\nimport { ORMDetector, ORMConfig } from '@driftjs/core'\nimport { DatabaseConfig, DetectionResult, FilePath } from '@driftjs/core'\nimport { exists, createFilePath, readJsonFile, findFiles } from '@driftjs/core'\n\nexport abstract class BaseORMDetector implements ORMDetector {\n  abstract name: string\n  \n  /**\n   * Detect if this ORM is present in the project\n   */\n  abstract detect(projectPath: string): Promise<DetectionResult>\n  \n  /**\n   * Extract ORM-specific configuration\n   */\n  abstract extractConfig(projectPath: string): Promise<ORMConfig | null>\n  \n  /**\n   * Extract database configuration from ORM setup\n   */\n  abstract getDatabaseConfig(projectPath: string): Promise<DatabaseConfig | null>\n  \n  /**\n   * Common helper: Check if package.json contains specific dependencies\n   */\n  protected async checkPackageJsonDependencies(\n    projectPath: string,\n    dependencies: string[]\n  ): Promise<{ found: string[]; missing: string[] }> {\n    const packageJsonPath = join(projectPath, 'package.json')\n    const packageResult = await readJsonFile<{ dependencies?: Record<string, string>; devDependencies?: Record<string, string> }>(packageJsonPath)\n    \n    if (!packageResult.success) {\n      return { found: [], missing: dependencies }\n    }\n    \n    const allDeps = {\n      ...packageResult.data.dependencies,\n      ...packageResult.data.devDependencies\n    }\n    \n    const found = dependencies.filter(dep => dep in allDeps)\n    const missing = dependencies.filter(dep => !(dep in allDeps))\n    \n    return { found, missing }\n  }\n  \n  /**\n   * Common helper: Check if specific files exist\n   */\n  protected async checkFiles(\n    projectPath: string,\n    filePaths: string[]\n  ): Promise<{ existing: FilePath[]; missing: string[] }> {\n    const existing: FilePath[] = []\n    const missing: string[] = []\n    \n    for (const filePath of filePaths) {\n      const fullPath = join(projectPath, filePath)\n      const fileExists = await exists(fullPath)\n      \n      if (fileExists) {\n        existing.push(await createFilePath(filePath, projectPath))\n      } else {\n        missing.push(filePath)\n      }\n    }\n    \n    return { existing, missing }\n  }\n  \n  /**\n   * Common helper: Find files matching patterns\n   */\n  protected async findFilesByPattern(\n    projectPath: string,\n    patterns: RegExp[],\n    directories: string[] = ['.']\n  ): Promise<string[]> {\n    const allFiles: string[] = []\n    \n    for (const directory of directories) {\n      const fullDirectory = join(projectPath, directory)\n      \n      for (const pattern of patterns) {\n        const files = await findFiles(fullDirectory, pattern, true)\n        allFiles.push(...files)\n      }\n    }\n    \n    return allFiles\n  }\n  \n  /**\n   * Common helper: Calculate confidence score based on evidence\n   */\n  protected calculateConfidence(evidence: {\n    required: { found: number; total: number }\n    optional: { found: number; total: number }\n    negative: number\n  }): number {\n    if (evidence.required.total === 0) {\n      return 0\n    }\n    \n    const requiredScore = evidence.required.found / evidence.required.total\n    const optionalScore = evidence.optional.total > 0 \n      ? evidence.optional.found / evidence.optional.total \n      : 0\n    \n    // Base score from required items (70% weight)\n    const baseScore = requiredScore * 0.7\n    \n    // Bonus from optional items (30% weight)\n    const bonusScore = optionalScore * 0.3\n    \n    // Penalty for negative evidence\n    const penalty = Math.min(evidence.negative * 0.1, 0.5)\n    \n    return Math.max(0, Math.min(1, baseScore + bonusScore - penalty))\n  }\n  \n  /**\n   * Parse database URL into DatabaseConfig\n   */\n  protected parseDatabaseUrl(url: string): DatabaseConfig | null {\n    try {\n      const parsed = new URL(url)\n      \n      let type: DatabaseConfig['type']\n      \n      switch (parsed.protocol) {\n        case 'postgresql:':\n        case 'postgres:':\n          type = 'postgresql'\n          break\n        case 'mysql:':\n          type = 'mysql'\n          break\n        case 'sqlite:':\n          type = 'sqlite'\n          break\n        default:\n          return null\n      }\n      \n      return {\n        type,\n        host: parsed.hostname || undefined,\n        port: parsed.port ? parseInt(parsed.port) : undefined,\n        database: parsed.pathname.slice(1), // Remove leading slash\n        username: parsed.username || undefined,\n        password: parsed.password || undefined,\n        url\n      }\n    } catch {\n      return null\n    }\n  }\n} ","/**\n * Prisma ORM detector implementation\n */\n\nimport { join } from 'path'\nimport { BaseORMDetector } from './base-detector.js'\nimport { PrismaConfig } from '@driftjs/core'\nimport { DatabaseConfig, DetectionResult } from '@driftjs/core'\nimport { readFileContent, createFilePath } from '@driftjs/core'\n\nexport class PrismaDetector extends BaseORMDetector {\n  name = 'prisma'\n  \n  /**\n   * Detect Prisma in the project\n   */\n  async detect(projectPath: string): Promise<DetectionResult> {\n    const evidence: string[] = []\n    const warnings: string[] = []\n    \n    // Check for Prisma dependencies\n    const { found: foundDeps, missing: missingDeps } = await this.checkPackageJsonDependencies(\n      projectPath,\n      ['prisma', '@prisma/client']\n    )\n    \n    evidence.push(...foundDeps.map(dep => `Found dependency: ${dep}`))\n    \n    // Check for Prisma schema file\n    const { existing: schemaFiles } = await this.checkFiles(projectPath, [\n      'prisma/schema.prisma',\n      'schema.prisma'\n    ])\n    \n    if (schemaFiles.length > 0) {\n      evidence.push(`Found schema file: ${schemaFiles[0].relative}`)\n    }\n    \n    // Check for migration directory\n    const { existing: migrationDirs } = await this.checkFiles(projectPath, [\n      'prisma/migrations'\n    ])\n    \n    if (migrationDirs.length > 0) {\n      evidence.push(`Found migrations directory: ${migrationDirs[0].relative}`)\n    }\n    \n    // Look for generated Prisma client\n    const generatedFiles = await this.findFilesByPattern(\n      projectPath,\n      [/node_modules\\/@prisma\\/client/],\n      ['node_modules']\n    )\n    \n    if (generatedFiles.length > 0) {\n      evidence.push('Found generated Prisma client')\n    }\n    \n    // Calculate confidence\n    const confidence = this.calculateConfidence({\n      required: { found: foundDeps.length, total: 2 }, // prisma + @prisma/client\n      optional: { found: schemaFiles.length + migrationDirs.length, total: 2 },\n      negative: 0\n    })\n    \n    // Add warnings for incomplete setup\n    if (foundDeps.length > 0 && schemaFiles.length === 0) {\n      warnings.push('Prisma dependency found but no schema.prisma file detected')\n    }\n    \n    if (schemaFiles.length > 0 && !foundDeps.includes('@prisma/client')) {\n      warnings.push('Schema file found but @prisma/client not installed')\n    }\n    \n    return {\n      found: confidence > 0.5,\n      confidence,\n      evidence,\n      warnings: warnings.length > 0 ? warnings : undefined\n    }\n  }\n  \n  /**\n   * Extract Prisma configuration\n   */\n  async extractConfig(projectPath: string): Promise<PrismaConfig | null> {\n    // Find schema file\n    const { existing: schemaFiles } = await this.checkFiles(projectPath, [\n      'prisma/schema.prisma',\n      'schema.prisma'\n    ])\n    \n    if (schemaFiles.length === 0) {\n      return null\n    }\n    \n    const schemaFile = schemaFiles[0]\n    const migrationDirectory = await createFilePath('prisma/migrations', projectPath)\n    \n    // Parse schema file for generator and database info\n    const schemaResult = await readFileContent(schemaFile.absolute)\n    if (!schemaResult.success) {\n      return null\n    }\n    \n    // Extract client generator config\n    let clientGenerator: PrismaConfig['clientGenerator']\n    const generatorMatch = schemaResult.data.match(/generator\\s+client\\s*{([^}]+)}/s)\n    if (generatorMatch) {\n      const generatorConfig = generatorMatch[1]\n      const providerMatch = generatorConfig.match(/provider\\s*=\\s*\"([^\"]+)\"/)\n      const outputMatch = generatorConfig.match(/output\\s*=\\s*\"([^\"]+)\"/)\n      \n      clientGenerator = {\n        provider: providerMatch?.[1] || 'prisma-client-js',\n        output: outputMatch?.[1]\n      }\n    }\n    \n    return {\n      type: 'prisma',\n      configFile: schemaFile,\n      migrationDirectory,\n      schemaFile,\n      dependencies: ['prisma', '@prisma/client'],\n      clientGenerator\n    }\n  }\n  \n  /**\n   * Extract database configuration from Prisma schema\n   */\n  async getDatabaseConfig(projectPath: string): Promise<DatabaseConfig | null> {\n    const config = await this.extractConfig(projectPath)\n    if (!config) {\n      return null\n    }\n    \n    // Read schema file\n    const schemaResult = await readFileContent(config.schemaFile.absolute)\n    if (!schemaResult.success) {\n      return null\n    }\n    \n    // Parse datasource block\n    const datasourceMatch = schemaResult.data.match(/datasource\\s+\\w+\\s*{([^}]+)}/s)\n    if (!datasourceMatch) {\n      return null\n    }\n    \n    const datasourceConfig = datasourceMatch[1]\n    \n    // Extract provider\n    const providerMatch = datasourceConfig.match(/provider\\s*=\\s*\"([^\"]+)\"/)\n    const provider = providerMatch?.[1]\n    \n    // Extract URL\n    const urlMatch = datasourceConfig.match(/url\\s*=\\s*env\\(\"([^\"]+)\"\\)/) ||\n                    datasourceConfig.match(/url\\s*=\\s*\"([^\"]+)\"/)\n    \n    if (!urlMatch) {\n      return null\n    }\n    \n    let databaseUrl: string\n    if (urlMatch[0].includes('env(')) {\n      // Environment variable reference\n      const envVar = urlMatch[1]\n      databaseUrl = process.env[envVar] || ''\n      \n      if (!databaseUrl) {\n        // Return basic config with type only\n        return {\n          type: this.mapPrismaProviderToType(provider),\n          database: 'unknown'\n        }\n      }\n    } else {\n      // Direct URL\n      databaseUrl = urlMatch[1]\n    }\n    \n    // Parse the database URL\n    const dbConfig = this.parseDatabaseUrl(databaseUrl)\n    if (dbConfig) {\n      return dbConfig\n    }\n    \n    // Fallback to provider-based detection\n    return {\n      type: this.mapPrismaProviderToType(provider),\n      database: 'unknown'\n    }\n  }\n  \n  /**\n   * Map Prisma provider to database type\n   */\n  private mapPrismaProviderToType(provider?: string): DatabaseConfig['type'] {\n    switch (provider) {\n      case 'postgresql':\n        return 'postgresql'\n      case 'mysql':\n        return 'mysql'\n      case 'sqlite':\n        return 'sqlite'\n      default:\n        return 'postgresql' // Default assumption\n    }\n  }\n} ","/**\n * Drizzle ORM detector implementation\n * Detects Drizzle projects by looking for drizzle.config.ts/js files and schema patterns\n */\n\nimport { BaseORMDetector } from './base-detector.js'\nimport { DrizzleConfig } from '@driftjs/core'\nimport { DatabaseConfig, DetectionResult } from '@driftjs/core'\nimport path from 'path'\nimport fs from 'fs/promises'\n\nexport class DrizzleDetector extends BaseORMDetector {\n  name = 'drizzle'\n  \n  async detect(projectPath: string): Promise<DetectionResult> {\n    const evidence: string[] = []\n    \n    try {\n      // Check for drizzle.config.ts/js files\n      const configFiles = [\n        'drizzle.config.ts',\n        'drizzle.config.js',\n        'drizzle.config.mjs'\n      ]\n      \n             const { existing: configFilesFound } = await this.checkFiles(projectPath, configFiles)\n       evidence.push(...configFilesFound.map(f => `Found config file: ${f.relative}`))\n       \n       // Check for package.json with drizzle dependencies\n       const deps = await this.checkPackageJsonDependencies(projectPath, ['drizzle-orm', 'drizzle-kit'])\n       evidence.push(...deps.found.map(dep => `Found dependency: ${dep}`))\n       \n       // Check for common schema file patterns\n       const schemaPatterns = [\n         'src/db/schema.ts',\n         'src/schema.ts',\n         'db/schema.ts',\n         'schema.ts',\n         'src/lib/db/schema.ts'\n       ]\n       \n       const { existing: schemaFiles } = await this.checkFiles(projectPath, schemaPatterns)\n       evidence.push(...schemaFiles.map(f => `Found schema file: ${f.relative}`))\n       \n       // Check for migrations directory\n       const migrationDirs = ['drizzle', 'migrations', 'drizzle/migrations']\n       const { existing: migrationDirsFound } = await this.checkFiles(projectPath, migrationDirs)\n       evidence.push(...migrationDirsFound.map(f => `Found migration directory: ${f.relative}`))\n      \n      // Calculate confidence using helper\n      const confidence = this.calculateConfidence({\n        required: { \n          found: deps.found.length > 0 ? 1 : 0, \n          total: 1 \n        },\n        optional: { \n          found: configFilesFound.length + schemaFiles.length + migrationDirsFound.length, \n          total: configFiles.length + schemaPatterns.length + migrationDirs.length \n        },\n        negative: 0\n      })\n      \n      return {\n        found: confidence > 0.3,\n        confidence: Math.round(confidence * 100),\n        evidence\n      }\n    } catch (error) {\n      return {\n        found: false,\n        confidence: 0,\n        evidence: [`Error detecting Drizzle: ${error}`]\n      }\n    }\n  }\n  \n  async extractConfig(projectPath: string): Promise<DrizzleConfig | null> {\n    try {\n      // Try to find drizzle config file\n      const configFiles = [\n        'drizzle.config.ts',\n        'drizzle.config.js',\n        'drizzle.config.mjs'\n      ]\n      \n      const { existing: configFilesFound } = await this.checkFiles(projectPath, configFiles)\n      if (configFilesFound.length === 0) {\n        return null\n      }\n      \n      const configFile = configFilesFound[0]\n      const configContent = await fs.readFile(configFile.absolute, 'utf-8')\n      \n      // Basic config parsing - in production, we'd use a proper TS/JS parser\n      const driver = this.extractConfigValue(configContent, 'dialect') || 'pg'\n      const validDrivers = ['pg', 'mysql2', 'better-sqlite3', 'sqlite'] as const\n      const mappedDriver = validDrivers.includes(driver as any) ? driver as typeof validDrivers[number] : 'pg'\n      \n      const config: DrizzleConfig = {\n        type: 'drizzle',\n        configFile,\n        driver: mappedDriver,\n        schemaPath: this.extractConfigValue(configContent, 'schema') || './src/db/schema.ts',\n        outDir: this.extractConfigValue(configContent, 'out') || './drizzle',\n        migrationDirectory: configFile, // Will be updated with proper migration directory\n        dependencies: ['drizzle-orm', 'drizzle-kit']\n      }\n      \n      return config\n    } catch (error) {\n      console.warn(`Failed to extract Drizzle config: ${error}`)\n      return null\n    }\n  }\n  \n  async getDatabaseConfig(projectPath: string): Promise<DatabaseConfig | null> {\n    try {\n      // Look for database URL in various places\n      const envFiles = ['.env', '.env.local', '.env.development']\n      const { existing: envFilesFound } = await this.checkFiles(projectPath, envFiles)\n      \n      for (const envFile of envFilesFound) {\n        const envContent = await fs.readFile(envFile.absolute, 'utf-8')\n        const dbUrl = this.extractEnvValue(envContent, 'DATABASE_URL')\n        if (dbUrl) {\n          const parsed = this.parseDatabaseUrl(dbUrl)\n          if (parsed) return parsed\n        }\n      }\n      \n      // Fallback: try to extract from drizzle config\n      const drizzleConfig = await this.extractConfig(projectPath)\n      if (!drizzleConfig) return null\n      \n      // Map Drizzle driver to database type\n      const driverMap: Record<string, 'postgresql' | 'mysql' | 'sqlite'> = {\n        'pg': 'postgresql',\n        'mysql2': 'mysql',\n        'better-sqlite3': 'sqlite'\n      }\n      \n      const dbType = driverMap[drizzleConfig.driver] || 'postgresql'\n      \n      return {\n        type: dbType,\n        host: 'localhost',\n        port: dbType === 'postgresql' ? 5432 : dbType === 'mysql' ? 3306 : undefined,\n        database: 'main'\n      }\n    } catch (error) {\n      console.warn(`Failed to extract database config: ${error}`)\n      return null\n    }\n  }\n  \n  private extractConfigValue(content: string, key: string): string | undefined {\n    // Simple regex-based extraction - in production, use proper AST parsing\n    const regex = new RegExp(`${key}:\\\\s*['\"]([^'\"]+)['\"]`)\n    const match = content.match(regex)\n    return match?.[1]\n  }\n  \n  private extractEnvValue(content: string, key: string): string | undefined {\n    const regex = new RegExp(`^${key}\\\\s*=\\\\s*(.+)$`, 'm')\n    const match = content.match(regex)\n    return match?.[1]?.replace(/['\"]/g, '').trim()\n  }\n} ","/**\n * TypeORM detector implementation\n * Detects TypeORM projects by looking for ormconfig files, entity patterns, and migrations\n */\n\nimport { BaseORMDetector } from './base-detector.js'\nimport { TypeORMConfig } from '@driftjs/core'\nimport { DatabaseConfig, DetectionResult } from '@driftjs/core'\nimport path from 'path'\nimport fs from 'fs/promises'\n\nexport class TypeORMDetector extends BaseORMDetector {\n  name = 'typeorm'\n  \n  async detect(projectPath: string): Promise<DetectionResult> {\n    const evidence: string[] = []\n    \n    try {\n      // Check for TypeORM config files\n      const configFiles = [\n        'ormconfig.ts',\n        'ormconfig.js',\n        'ormconfig.json',\n        'typeorm.config.ts',\n        'typeorm.config.js',\n        'src/data-source.ts',\n        'src/data-source.js'\n      ]\n      \n      const { existing: configFilesFound } = await this.checkFiles(projectPath, configFiles)\n      evidence.push(...configFilesFound.map(f => `Found config file: ${f.relative}`))\n      \n      // Check for package.json with TypeORM dependencies\n      const deps = await this.checkPackageJsonDependencies(projectPath, ['typeorm', '@nestjs/typeorm'])\n      evidence.push(...deps.found.map(dep => `Found dependency: ${dep}`))\n      \n      // Check for common entity file patterns\n      const entityPatterns = await this.findFilesByPattern(\n        projectPath,\n        [/\\.entity\\.(ts|js)$/, /@Entity\\(/],\n        ['src', 'entities', 'entity']\n      )\n      if (entityPatterns.length > 0) {\n        evidence.push(`Found ${entityPatterns.length} entity files`)\n      }\n      \n      // Check for migrations directory\n      const migrationDirs = ['src/migrations', 'migrations', 'database/migrations']\n      const { existing: migrationDirsFound } = await this.checkFiles(projectPath, migrationDirs)\n      evidence.push(...migrationDirsFound.map(f => `Found migration directory: ${f.relative}`))\n      \n      // Check for migration files\n      const migrationPatterns = await this.findFilesByPattern(\n        projectPath,\n        [/\\d+.*\\.(ts|js)$/],\n        ['src/migrations', 'migrations', 'database/migrations']\n      )\n      if (migrationPatterns.length > 0) {\n        evidence.push(`Found ${migrationPatterns.length} migration files`)\n      }\n      \n      // Calculate confidence using helper\n      const confidence = this.calculateConfidence({\n        required: { \n          found: deps.found.length > 0 ? 1 : 0, \n          total: 1 \n        },\n        optional: { \n          found: configFilesFound.length + (entityPatterns.length > 0 ? 1 : 0) + migrationDirsFound.length + (migrationPatterns.length > 0 ? 1 : 0), \n          total: 4 \n        },\n        negative: 0\n      })\n      \n      return {\n        found: confidence > 0.3,\n        confidence: Math.round(confidence * 100),\n        evidence\n      }\n    } catch (error) {\n      return {\n        found: false,\n        confidence: 0,\n        evidence: [`Error detecting TypeORM: ${error}`]\n      }\n    }\n  }\n  \n  async extractConfig(projectPath: string): Promise<TypeORMConfig | null> {\n    try {\n      // Try to find TypeORM config file\n      const configFiles = [\n        'ormconfig.ts',\n        'ormconfig.js',\n        'ormconfig.json',\n        'typeorm.config.ts',\n        'typeorm.config.js',\n        'src/data-source.ts',\n        'src/data-source.js'\n      ]\n      \n      const { existing: configFilesFound } = await this.checkFiles(projectPath, configFiles)\n      if (configFilesFound.length === 0) {\n        return null\n      }\n      \n      const configFile = configFilesFound[0]\n      let entities: string[] = []\n      let migrations: string[] = []\n      \n      if (configFile.relative.endsWith('.json')) {\n        // Parse JSON config\n        const configContent = await fs.readFile(configFile.absolute, 'utf-8')\n        const jsonConfig = JSON.parse(configContent)\n        entities = Array.isArray(jsonConfig.entities) ? jsonConfig.entities : ['src/**/*.entity.{ts,js}']\n        migrations = Array.isArray(jsonConfig.migrations) ? jsonConfig.migrations : ['src/migrations/*.{ts,js}']\n      } else {\n        // Parse TypeScript/JavaScript config (basic parsing)\n        const configContent = await fs.readFile(configFile.absolute, 'utf-8')\n        entities = this.extractArrayValue(configContent, 'entities') || ['src/**/*.entity.{ts,js}']\n        migrations = this.extractArrayValue(configContent, 'migrations') || ['src/migrations/*.{ts,js}']\n      }\n      \n      const config: TypeORMConfig = {\n        type: 'typeorm',\n        configFile,\n        entities,\n        migrations,\n        migrationDirectory: configFile, // Will be updated with proper migration directory  \n        dependencies: ['typeorm'],\n        cli: {\n          migrationsDir: 'src/migrations',\n          entitiesDir: 'src/entities'\n        }\n      }\n      \n      return config\n    } catch (error) {\n      console.warn(`Failed to extract TypeORM config: ${error}`)\n      return null\n    }\n  }\n  \n  async getDatabaseConfig(projectPath: string): Promise<DatabaseConfig | null> {\n    try {\n      // Look for database URL in various places\n      const envFiles = ['.env', '.env.local', '.env.development']\n      const { existing: envFilesFound } = await this.checkFiles(projectPath, envFiles)\n      \n      for (const envFile of envFilesFound) {\n        const envContent = await fs.readFile(envFile.absolute, 'utf-8')\n        const dbUrl = this.extractEnvValue(envContent, 'DATABASE_URL') || \n                      this.extractEnvValue(envContent, 'DB_URL') ||\n                      this.extractEnvValue(envContent, 'TYPEORM_URL')\n        if (dbUrl) {\n          const parsed = this.parseDatabaseUrl(dbUrl)\n          if (parsed) return parsed\n        }\n      }\n      \n      // Try to extract from TypeORM config\n      const typeormConfig = await this.extractConfig(projectPath)\n      if (typeormConfig?.configFile) {\n        const configContent = await fs.readFile(typeormConfig.configFile.absolute, 'utf-8')\n        \n        // Extract database configuration from config file\n        const type = this.extractConfigValue(configContent, 'type')\n        const host = this.extractConfigValue(configContent, 'host')\n        const port = this.extractConfigValue(configContent, 'port')\n        const database = this.extractConfigValue(configContent, 'database')\n        const username = this.extractConfigValue(configContent, 'username')\n        const password = this.extractConfigValue(configContent, 'password')\n        \n        if (type && database) {\n          const dbTypeMap: Record<string, 'postgresql' | 'mysql' | 'sqlite'> = {\n            'postgres': 'postgresql',\n            'postgresql': 'postgresql',\n            'mysql': 'mysql',\n            'mariadb': 'mysql',\n            'sqlite': 'sqlite'\n          }\n          \n          const mappedType = dbTypeMap[type] || 'postgresql'\n          \n          return {\n            type: mappedType,\n            host: host || 'localhost',\n            port: port ? parseInt(port) : (mappedType === 'postgresql' ? 5432 : mappedType === 'mysql' ? 3306 : undefined),\n            database,\n            username,\n            password\n          }\n        }\n      }\n      \n      // Fallback defaults\n      return {\n        type: 'postgresql',\n        host: 'localhost',\n        port: 5432,\n        database: 'main'\n      }\n    } catch (error) {\n      console.warn(`Failed to extract database config: ${error}`)\n      return null\n    }\n  }\n  \n  private extractConfigValue(content: string, key: string): string | undefined {\n    // Simple regex-based extraction - in production, use proper AST parsing\n    const regex = new RegExp(`${key}:\\\\s*['\"]([^'\"]+)['\"]`)\n    const match = content.match(regex)\n    return match?.[1]\n  }\n  \n  private extractArrayValue(content: string, key: string): string[] | undefined {\n    // Basic array extraction - in production, use proper AST parsing\n    const regex = new RegExp(`${key}:\\\\s*\\\\[([^\\\\]]+)\\\\]`)\n    const match = content.match(regex)\n    if (!match) return undefined\n    \n    return match[1]\n      .split(',')\n      .map(item => item.trim().replace(/['\"]/g, ''))\n      .filter(item => item.length > 0)\n  }\n  \n  private extractEnvValue(content: string, key: string): string | undefined {\n    const regex = new RegExp(`^${key}\\\\s*=\\\\s*(.+)$`, 'm')\n    const match = content.match(regex)\n    return match?.[1]?.replace(/['\"]/g, '').trim()\n  }\n} ","/**\n * flow sync - Detect ORM changes and create enhanced migration plan\n */\n\nimport { confirm, select } from '@clack/prompts'\nimport { getFlowConfig, GlobalOptions } from '../lib/config.js'\nimport { createSpinner } from '../lib/prompts.js'\nimport { PrismaDetector, DrizzleDetector, TypeORMDetector } from '@driftjs/analyzer'\nimport { EnhancementEngine } from '@driftjs/enhancer'\nimport fs from 'fs-extra'\nimport path from 'node:path'\nimport { diffChars } from 'diff'\nimport pc from 'picocolors'\nimport { execa } from 'execa'\n\nexport interface SyncOptions {\n  force?: boolean\n  orm?: 'prisma' | 'drizzle' | 'typeorm' | 'auto'\n  project?: string\n  yes?: boolean\n}\n\nexport async function syncCommand(options: SyncOptions, globalOptions: GlobalOptions): Promise<void> {\n  const spinner = createSpinner('Detecting ORM setup and analyzing schema changes...')\n  \n  const projectPath = options.project ? path.resolve(options.project) : process.cwd()\n  const cfg = await getFlowConfig(globalOptions, projectPath)\n  const envCfg = cfg.environments[cfg.defaultEnvironment]\n  \n  let detectedORM: string | null = null\n  const detectors = [\n    { name: 'prisma', detector: new PrismaDetector() },\n    { name: 'drizzle', detector: new DrizzleDetector() },\n    { name: 'typeorm', detector: new TypeORMDetector() }\n  ]\n\n  if (options.orm && options.orm !== 'auto') {\n    detectedORM = options.orm\n  } else {\n    for (const { name, detector } of detectors) {\n      const result = await detector.detect(projectPath)\n      if (result.found) {\n        detectedORM = name\n        break\n      }\n    }\n  }\n\n  if (!detectedORM) {\n    spinner.fail('ORM detection failed')\n    console.log(pc.red('No supported ORM detected. Make sure you have Prisma, Drizzle, or TypeORM configured.'))\n    return\n  }\n\n  spinner.update(`Detected ${detectedORM.toUpperCase()} - analyzing schema changes...`)\n\n  const detector = detectors.find(d => d.name === detectedORM)?.detector\n  if (!detector) {\n    spinner.fail('Detector not found')\n    return\n  }\n\n  const ormConfig = await detector.extractConfig(projectPath)\n  \n  const hasChanges = await checkForSchemaChanges(detectedORM, ormConfig, projectPath)\n  \n  if (!hasChanges && !options.force) {\n    spinner.succeed('Schema analysis completed')\n    console.log(pc.green('üéâ No pending schema changes detected. Your migrations are up to date.'))\n    console.log(pc.gray('Use --force to re-analyze existing migrations for enhancements.'))\n    return\n  }\n\n  const migrationsDir = envCfg.migrationsPath || (ormConfig?.migrationDirectory?.relative) || './migrations'\n  const absoluteMigrationsDir = path.resolve(projectPath, migrationsDir)\n\n  if (hasChanges) {\n    spinner.update('Generating migration plan for schema changes...')\n    await handleSchemaChanges(detectedORM, ormConfig, absoluteMigrationsDir, globalOptions, projectPath, options)\n  } else {\n    spinner.update('Analyzing existing migrations for enhancements...')\n    await enhanceExistingMigrations(absoluteMigrationsDir, globalOptions, options)\n  }\n\n  spinner.succeed('Sync completed')\n}\n\nasync function checkForSchemaChanges(orm: string, config: any, projectPath: string): Promise<boolean> {\n  switch (orm) {\n    case 'prisma':\n      return await checkPrismaChanges(config, projectPath)\n    case 'drizzle':\n      return await checkDrizzleChanges(config, projectPath)\n    case 'typeorm':\n      return await checkTypeORMChanges(config, projectPath)\n    default:\n      return false\n  }\n}\n\nasync function checkPrismaChanges(config: any, projectPath: string): Promise<boolean> {\n  try {\n    const schemaPath = path.join(projectPath, 'prisma', 'schema.prisma')\n    const migrationsPath = path.join(projectPath, 'prisma', 'migrations')\n    \n    if (!await fs.pathExists(schemaPath)) return false\n    if (!await fs.pathExists(migrationsPath)) return true\n    \n    try {\n      await execa('npx prisma migrate status', { cwd: projectPath })\n      try {\n        const { stdout } = await execa('npx prisma migrate diff --from-migrations ./prisma/migrations --to-schema-datamodel ./prisma/schema.prisma', { cwd: projectPath })\n        return stdout.trim().length > 0\n      } catch {\n        return true\n      }\n    } catch {\n      const schemaStats = await fs.stat(schemaPath)\n      const migrationFiles = await fs.readdir(migrationsPath)\n      if (migrationFiles.length === 0) return true\n      const migrationDirs = migrationFiles.filter(file => file.match(/^\\d{14}_/))\n      if (migrationDirs.length === 0) return true\n      const latestMigration = migrationDirs.sort().pop()\n      const latestMigrationPath = path.join(migrationsPath, latestMigration!)\n      const migrationStats = await fs.stat(latestMigrationPath)\n      return schemaStats.mtime > migrationStats.mtime\n    }\n  } catch (error) {\n    console.warn('Error checking Prisma changes:', error)\n    return false\n  }\n}\n\nasync function checkDrizzleChanges(config: any, projectPath: string): Promise<boolean> {\n  // FIXME: This is a temporary hack to bypass the unreliable drizzle-kit check\n  return true\n}\n\nasync function checkTypeORMChanges(config: any, projectPath: string): Promise<boolean> {\n  try {\n    try {\n      const { stdout } = await execa('npx typeorm migration:show', { cwd: projectPath })\n      return !stdout.includes('No migrations are pending')\n    } catch {\n      const entityDirs = ['src/entities', 'src/entity', 'entities']\n      const migrationsDir = config?.migrationDirectory || './src/migrations'\n      const migrationsDirPath = path.join(projectPath, migrationsDir)\n      \n      if (!await fs.pathExists(migrationsDirPath)) return true\n      \n      for (const entityDir of entityDirs) {\n        const entityDirPath = path.join(projectPath, entityDir)\n        if (await fs.pathExists(entityDirPath)) {\n          const entityFiles = await fs.readdir(entityDirPath)\n          const tsFiles = entityFiles.filter(f => f.endsWith('.ts') || f.endsWith('.js'))\n          \n          for (const entityFile of tsFiles) {\n            const entityPath = path.join(entityDirPath, entityFile)\n            const entityStats = await fs.stat(entityPath)\n            const migrationFiles = await fs.readdir(migrationsDirPath)\n            if (migrationFiles.length === 0) return true\n            const latestMigration = migrationFiles.sort().pop()\n            const latestMigrationPath = path.join(migrationsDirPath, latestMigration!)\n            const migrationStats = await fs.stat(latestMigrationPath)\n            if (entityStats.mtime > migrationStats.mtime) {\n              return true\n            }\n          }\n        }\n      }\n      return false\n    }\n  } catch (error) {\n    console.warn('Error checking TypeORM changes:', error)\n    return false\n  }\n}\n\nasync function handleSchemaChanges(\n  orm: string,\n  config: any,\n  migrationsDir: string,\n  globalOptions: GlobalOptions,\n  projectPath: string,\n  options: SyncOptions,\n): Promise<void> {\n  const migrationName = `flow_change_${Date.now()}`\n  let generateCmd = ''\n\n  switch (orm) {\n    case 'prisma':\n      generateCmd = `npx prisma migrate dev --name ${migrationName}`\n      break\n    case 'drizzle':\n      // The --dialect flag conflicts with the --config flag which drizzle-kit uses implicitly.\n      // Drizzle Kit will detect the dialect from the config file.\n      generateCmd = `npx drizzle-kit generate`\n      break\n    case 'typeorm':\n      const migPath = path.join(migrationsDir, migrationName)\n      generateCmd = `npx typeorm migration:generate ${migPath}`\n      break\n  }\n\n  const spinner = createSpinner(`Running ${orm} to generate migration...`)\n  try {\n    const { stdout, stderr } = await execa(generateCmd, { cwd: projectPath, shell: true })\n    if (globalOptions.debug) {\n      console.log(stdout)\n      if (stderr) console.error(pc.yellow(stderr))\n    }\n    spinner.succeed('ORM migration generated successfully.')\n    await enhanceExistingMigrations(migrationsDir, globalOptions, options)\n  } catch (error: any) {\n    spinner.fail('Migration generation failed.')\n    console.error(pc.red(error.stderr || error.message))\n    console.log(pc.yellow(`Could not automatically generate migration. Please run the following command manually:\\n${generateCmd}`))\n  }\n}\n\nasync function enhanceExistingMigrations(\n  migrationsDir: string,\n  globalOptions: GlobalOptions,\n  options: SyncOptions,\n): Promise<void> {\n  const spinner = createSpinner('Analyzing migrations for enhancements...')\n  if (!(await fs.pathExists(migrationsDir))) {\n    spinner.fail(`Migrations directory not found: ${migrationsDir}`)\n    return\n  }\n\n  const files = await fs.readdir(migrationsDir)\n  const migrationFiles = files.filter(file => file.endsWith('.sql') || file.endsWith('.ts') || file.endsWith('.js'));\n\n  if (migrationFiles.length === 0) {\n    spinner.succeed('No migration files found to analyze.')\n    return\n  }\n  \n  spinner.update(`Found ${migrationFiles.length} migration(s) to analyze for enhancements.`)\n\n  const engine = new EnhancementEngine();\n\n  for (const file of migrationFiles) {\n    spinner.update(`Analyzing ${file}...`)\n    const filePath = path.join(migrationsDir, file);\n    const content = await fs.readFile(filePath, 'utf-8');\n    const sql = extractSQLFromMigrationFile(content);\n    \n    const migrationFile: any = {\n      path: filePath,\n      name: file,\n      up: sql,\n      down: '',\n      timestamp: new Date(),\n      operations: [],\n      checksum: '',\n    };\n\n    const enhanced = await engine.enhance(migrationFile);\n\n    if (enhanced.original.up !== enhanced.enhanced.up) {\n      const originalColor = (text: string) => pc.red(`- ${text}`);\n      const enhancedColor = (text: string) => pc.green(`+ ${text}`);\n      const diff = diffChars(enhanced.original.up, enhanced.enhanced.up);\n      let diffOutput = '';\n      diff.forEach(part => {\n        const color = part.added ? enhancedColor : part.removed ? originalColor : pc.gray;\n        diffOutput += color(part.value);\n      });\n      console.log(pc.bold(`\\nEnhancements for ${file}:`))\n      console.log(diffOutput)\n\n      const proceed = options.yes ? true : await confirm({ message: `Apply these enhancements to ${file}?` })\n\n      if (proceed) {\n        try {\n          const newContent = await replaceEnhancedSQLInMigrationFile(filePath, enhanced.enhanced.up, enhanced.enhanced.down);\n          await fs.writeFile(filePath, newContent, 'utf-8');\n          console.log(pc.green(`‚úÖ Updated ${file}`))\n        } catch (error) {\n          console.log(pc.yellow(`‚ö†Ô∏è  Could not automatically update ${file}: ${error}`))\n          console.log(pc.gray('Enhanced UP SQL:'))\n          console.log(enhanced.enhanced.up)\n          if (enhanced.enhanced.down) {\n            console.log(pc.gray('Enhanced DOWN SQL:'))\n            console.log(enhanced.enhanced.down)\n          }\n        }\n      } else {\n        console.log(pc.gray(`Skipped ${file}`))\n      }\n    } else {\n      console.log(pc.gray('No enhancements needed.'))\n    }\n  }\n  spinner.succeed('Enhancement analysis completed.')\n}\n\nfunction extractSQLFromMigrationFile(content: string): string {\n  const sqlPatterns = [\n    /queryRunner\\.query\\s*\\(\\s*[`\"']([^`\"']+)[`\"']/g,\n    /sql\\s*`([^`]+)`/g,\n    /\"((?:CREATE|ALTER|DROP|INSERT|UPDATE|DELETE)[^\"]+)\"/gi\n  ];\n  let extractedSQL = '';\n  for (const pattern of sqlPatterns) {\n    let match;\n    while ((match = pattern.exec(content)) !== null) {\n      extractedSQL += match[1] + ';\\n';\n    }\n  }\n  return extractedSQL || content;\n}\n\nasync function replaceEnhancedSQLInMigrationFile(filePath: string, upSQL: string, downSQL?: string): Promise<string> {\n  const content = await fs.readFile(filePath, 'utf-8');\n  let updatedContent = content;\n\n  updatedContent = updatedContent.replace(/queryRunner\\.query\\s*\\(\\s*[`\"']([^`\"']+)[`\"']/g, `queryRunner.query(\\`${upSQL.trim()}\\`)`);\n  updatedContent = updatedContent.replace(/sql\\s*`([^`]+)`/g, `sql\\`${upSQL.trim()}\\``);\n  updatedContent = updatedContent.replace(/\"((?:CREATE|ALTER|DROP|INSERT|UPDATE|DELETE)[^\"]+)\"/gi, `\"${upSQL.trim()}\"`);\n\n  if (downSQL) {\n    updatedContent = updatedContent.replace(/(public async down\\(.*?\\): Promise<void> \\{[\\s\\S]*?queryRunner\\.query\\s*\\(\\s*[`\"'])([^`\"']+)([`\"'])/, `$1${downSQL.trim()}$3`);\n  }\n\n  return updatedContent;\n}\n","export interface GlobalOptions {\n  debug?: boolean\n  config?: string\n  dryRun?: boolean\n}\n\nimport fsExtra from 'fs-extra'\nimport { resolve, dirname } from 'node:path'\n\n/**\n * Locate and parse flow.config.json.\n * If --config is supplied use that path, otherwise walk parent directories.\n */\nexport async function getFlowConfig(global: GlobalOptions, projectPath?: string) {\n  const configPath = await findConfigFile(projectPath || process.cwd(), global.config)\n  return JSON.parse(await fsExtra.readFile(configPath, 'utf8'))\n}\n\nasync function findConfigFile(startDir: string, explicit?: string): Promise<string> {\n  if (explicit) {\n    const p = resolve(explicit)\n    if (await fsExtra.pathExists(p)) return p\n    throw new Error(`Config file not found at ${p}`)\n  }\n\n  let dir = startDir\n  while (true) {\n    const candidate = resolve(dir, 'flow.config.json')\n    if (await fsExtra.pathExists(candidate)) return candidate\n    const parent = dirname(dir)\n    if (parent === dir) break\n    dir = parent\n  }\n  throw new Error('flow.config.json not found')\n} ","/**\n * flow test - Test migration safety\n */\n\nimport { spinner } from '@clack/prompts'\nimport { getFlowConfig, GlobalOptions } from '../lib/config.js'\nimport path from 'node:path'\n\nexport interface TestOptions {\n  project?: string\n}\n\nexport async function testCommand(options: TestOptions, globalOptions: GlobalOptions): Promise<void> {\n  const s = spinner()\n  const projectPath = options.project ? path.resolve(options.project) : process.cwd()\n  const cfg = await getFlowConfig(globalOptions, projectPath)\n  if (globalOptions.debug) {\n    console.log('Testing migrations against env:', cfg.defaultEnvironment)\n  }\n  \n  s.start('Running migration tests...')\n  \n  // TODO: Implement migration testing\n  await new Promise(resolve => setTimeout(resolve, 2000))\n  \n  s.stop('Safety tests completed')\n  \n  console.log('‚úÖ All safety checks passed')\n} ","/**\n * flow apply - Apply enhanced migrations\n */\n\nimport { confirm, select } from '@clack/prompts'\nimport { getFlowConfig, GlobalOptions } from '../lib/config.js'\nimport { createSpinner } from '../lib/prompts.js'\nimport fs from 'fs-extra'\nimport path from 'node:path'\nimport pc from 'picocolors'\nimport { Client as PgClient } from 'pg'\nimport mysql from 'mysql2/promise'\nimport sqlite3 from 'sqlite3'\n\nexport interface ApplyOptions {\n  migration?: string\n  target?: string\n  project?: string\n  yes?: boolean\n}\n\ninterface DatabaseConnection {\n  type: 'postgresql' | 'mysql' | 'sqlite'\n  client: any\n}\n\nexport async function applyCommand(options: ApplyOptions, globalOptions: GlobalOptions): Promise<void> {\n  const projectPath = options.project ? path.resolve(options.project) : process.cwd()\n  const cfg = await getFlowConfig(globalOptions, projectPath)\n  const envCfg = cfg.environments[cfg.defaultEnvironment]\n  \n  if (globalOptions.debug) {\n    console.log('Applying migration using env:', cfg.defaultEnvironment)\n  }\n  \n  const spinner = createSpinner('Connecting to database...')\n  \n  // Connect to database\n  let connection: DatabaseConnection | null = null\n  try {\n    console.log('connecting to database...'); // DEBUG LOG\n    connection = await connectToDatabase(envCfg)\n    console.log('connected to database'); // DEBUG LOG\n    spinner.update('Connected to database successfully')\n  } catch (error) {\n    console.log('error connecting to database', error); // DEBUG LOG\n    spinner.fail('Failed to connect to database')\n    console.log(pc.red(`‚ùå Database connection failed: ${error}`))\n    return\n  }\n  \n  try {\n    // Ensure migrations tracking table exists\n    spinner.update('Ensuring migration tracking table exists...')\n    await ensureMigrationsTable(connection)\n    console.log('ensured migrations table'); // DEBUG LOG\n    \n    // Find migrations to apply\n    spinner.update('Finding migrations to apply...')\n    const migrationsDir = envCfg.migrationsPath || './migrations'\n    const absoluteMigrationsDir = path.resolve(projectPath, migrationsDir)\n    \n    const pendingMigrations = await findPendingMigrations(connection, absoluteMigrationsDir, options.migration)\n    console.log('found pending migrations'); // DEBUG LOG\n    \n    if (pendingMigrations.length === 0) {\n      spinner.succeed('No pending migrations to apply')\n      console.log(pc.green('‚úÖ Database is up to date'))\n      return\n    }\n    \n    spinner.stop()\n    \n    console.log(`\\nüìã Found ${pendingMigrations.length} pending migration(s):`)\n    pendingMigrations.forEach((migration, idx) => {\n      console.log(`  ${idx + 1}. ${pc.cyan(migration.name)}`)\n    })\n    \n    if (globalOptions.dryRun) {\n      console.log(pc.yellow('\\nüîç Dry run mode - showing what would be applied:'))\n      for (const migration of pendingMigrations) {\n        console.log(`\\n${pc.cyan(`--- ${migration.name} ---`)}`)\n        console.log(pc.gray(migration.content))\n      }\n      return\n    }\n    \n    const proceed = options.yes ? true : await confirm({\n      message: `Apply ${pendingMigrations.length} migration(s) to the database?`\n    })\n    console.log('confirmed apply'); // DEBUG LOG\n    \n    if (!proceed) {\n      console.log(pc.gray('Migration cancelled.'))\n      return\n    }\n    \n    // Apply migrations\n    const applySpinner = createSpinner('Applying migrations...')\n    \n    for (const migration of pendingMigrations) {\n      try {\n        applySpinner.update(`Applying ${migration.name}...`)\n        \n        await applyMigration(connection, migration)\n        await recordMigrationApplied(connection, migration)\n        \n        if (globalOptions.debug) {\n          console.log(pc.green(`  ‚úÖ Applied ${migration.name}`))\n        }\n      } catch (error) {\n        applySpinner.fail(`Failed to apply ${migration.name}`)\n        console.log(pc.red(`‚ùå Migration failed: ${error}`))\n        \n        // Ask if they want to continue with remaining migrations\n        if (pendingMigrations.indexOf(migration) < pendingMigrations.length - 1) {\n          const continueApplying = await confirm({\n            message: 'Continue applying remaining migrations?'\n          })\n          \n          if (!continueApplying) {\n            console.log(pc.yellow('‚ö†Ô∏è  Migration process stopped'))\n            return\n          }\n        }\n      }\n    }\n    \n    applySpinner.succeed('All migrations applied successfully')\n    console.log(pc.green('‚úÖ Enhanced migrations applied successfully'))\n    \n  } finally {\n    // Close database connection\n    if (connection) {\n      await closeDatabaseConnection(connection)\n    }\n  }\n}\n\nasync function connectToDatabase(envCfg: any): Promise<DatabaseConnection> {\n  console.log('in connectToDatabase'); // DEBUG LOG\n  const connectionString = envCfg.db_connection_string || envCfg.databaseUrl;\n  console.log('connectionString:', connectionString); // DEBUG LOG\n  \n  if (!connectionString) {\n    throw new Error('Database connection string not found in flow.config.json. Please provide \"db_connection_string\" or \"databaseUrl\".')\n  }\n\n  const dbType = connectionString.split(':')[0];\n  console.log('dbType:', dbType); // DEBUG LOG\n\n  switch (dbType) {\n    case 'postgresql':\n      console.log('connecting to postgresql'); // DEBUG LOG\n      const pgClient = new PgClient({ connectionString })\n      await pgClient.connect()\n      console.log('connected to postgresql'); // DEBUG LOG\n      return { type: 'postgresql', client: pgClient }\n      \n    case 'mysql':\n      console.log('connecting to mysql'); // DEBUG LOG\n      const mysqlConnection = await mysql.createConnection(connectionString)\n      console.log('connected to mysql'); // DEBUG LOG\n      return { type: 'mysql', client: mysqlConnection }\n      \n    case 'sqlite':\n      console.log('connecting to sqlite'); // DEBUG LOG\n      const sqlitePath = connectionString.substring('sqlite:'.length);\n      const sqliteDb = new sqlite3.Database(sqlitePath || './database.db')\n      console.log('connected to sqlite'); // DEBUG LOG\n      return { type: 'sqlite', client: sqliteDb }\n      \n    default:\n      throw new Error(`Unsupported database type: ${dbType}`)\n  }\n}\n\nasync function ensureMigrationsTable(connection: DatabaseConnection): Promise<void> {\n  const createTableQuery = (() => {\n    switch (connection.type) {\n      case 'postgresql':\n        return `\n          CREATE TABLE IF NOT EXISTS flow_migrations (\n            id SERIAL PRIMARY KEY,\n            name VARCHAR(255) NOT NULL UNIQUE,\n            checksum VARCHAR(64),\n            applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n          )\n        `\n      case 'mysql':\n        return `\n          CREATE TABLE IF NOT EXISTS flow_migrations (\n            id INT AUTO_INCREMENT PRIMARY KEY,\n            name VARCHAR(255) NOT NULL UNIQUE,\n            checksum VARCHAR(64),\n            applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n          )\n        `\n      case 'sqlite':\n        return `\n          CREATE TABLE IF NOT EXISTS flow_migrations (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            name TEXT NOT NULL UNIQUE,\n            checksum TEXT,\n            applied_at DATETIME DEFAULT CURRENT_TIMESTAMP\n          )\n        `\n    }\n  })()\n  \n  await executeQuery(connection, createTableQuery)\n}\n\nasync function findPendingMigrations(connection: DatabaseConnection, migrationsDir: string, targetMigration?: string): Promise<Array<{name: string, path: string, content: string}>> {\n  if (!await fs.pathExists(migrationsDir)) {\n    throw new Error(`Migrations directory not found: ${migrationsDir}`)\n  }\n  \n  const appliedMigrations = await executeQuery(connection, 'SELECT name FROM flow_migrations ORDER BY applied_at')\n  const appliedNames = new Set(appliedMigrations.map((row: any) => row.name))\n  \n  const allFiles = await fs.readdir(migrationsDir)\n  const migrationFiles = allFiles\n    .filter(f => f.endsWith('.sql') || f.endsWith('.ts') || f.endsWith('.js'))\n    .sort()\n  \n  const pendingMigrations = []\n  \n  for (const file of migrationFiles) {\n    const migrationName = path.parse(file).name\n    \n    if (appliedNames.has(migrationName)) {\n      continue\n    }\n    \n    if (targetMigration && migrationName !== targetMigration) {\n      continue\n    }\n    \n    const filePath = path.join(migrationsDir, file)\n    let content = await fs.readFile(filePath, 'utf-8')\n    \n    if (file.endsWith('.ts') || file.endsWith('.js')) {\n      content = extractSQLFromMigrationFile(content)\n    }\n    \n    pendingMigrations.push({\n      name: migrationName,\n      path: filePath,\n      content\n    })\n    \n    if (targetMigration && migrationName === targetMigration) {\n      break\n    }\n  }\n  \n  return pendingMigrations\n}\n\nasync function applyMigration(connection: DatabaseConnection, migration: {name: string, content: string}): Promise<void> {\n  // Split migration content by semicolon and execute each statement\n  const statements = migration.content\n    .split(';')\n    .map(stmt => stmt.trim())\n    .filter(stmt => stmt.length > 0)\n  \n  for (const statement of statements) {\n    if (statement.trim()) {\n      await executeQuery(connection, statement)\n    }\n  }\n}\n\nasync function recordMigrationApplied(connection: DatabaseConnection, migration: {name: string, content: string}): Promise<void> {\n  // Simple checksum calculation (could be improved)\n  const checksum = Buffer.from(migration.content).toString('base64').slice(0, 32)\n  \n  const insertQuery = (() => {\n    switch (connection.type) {\n      case 'postgresql':\n        return 'INSERT INTO flow_migrations (name, checksum) VALUES ($1, $2)'\n      case 'mysql':\n        return 'INSERT INTO flow_migrations (name, checksum) VALUES (?, ?)'\n      case 'sqlite':\n        return 'INSERT INTO flow_migrations (name, checksum) VALUES (?, ?)'\n    }\n  })()\n  \n  await executeQuery(connection, insertQuery, [migration.name, checksum])\n}\n\nasync function executeQuery(connection: DatabaseConnection, query: string, params?: any[]): Promise<any[]> {\n  return new Promise((resolve, reject) => {\n    switch (connection.type) {\n      case 'postgresql':\n        connection.client.query(query, params, (err: any, result: any) => {\n          if (err) return reject(err)\n          resolve(result.rows)\n        })\n        break\n      case 'mysql':\n        connection.client.query(query, params)\n          .then(([rows]: any) => resolve(rows))\n          .catch((err: any) => reject(err))\n        break\n      case 'sqlite':\n        connection.client.all(query, params, (err: any, rows: any) => {\n          if (err) return reject(err)\n          resolve(rows)\n        })\n        break\n    }\n  })\n}\n\nasync function closeDatabaseConnection(connection: DatabaseConnection): Promise<void> {\n  switch (connection.type) {\n    case 'postgresql':\n      await connection.client.end()\n      break\n    case 'mysql':\n      await connection.client.end()\n      break\n    case 'sqlite':\n      connection.client.close()\n      break\n  }\n}\n\nfunction extractSQLFromMigrationFile(content: string): string {\n  // Basic extraction - look for SQL in strings, template literals, etc.\n  const sqlPatterns = [\n    /queryRunner\\.query\\s*\\(\\s*[`\"']([^`\"']+)[`\"']/g,\n    /sql\\s*`([^`]+)`/g,\n    /\"((?:CREATE|ALTER|DROP|INSERT|UPDATE|DELETE)[^\"]+)\"/gi\n  ]\n  \n  let extractedSQL = ''\n  \n  for (const pattern of sqlPatterns) {\n    let match\n    while ((match = pattern.exec(content)) !== null) {\n      extractedSQL += match[1] + ';\\n'\n    }\n  }\n  \n  return extractedSQL || content\n} ","/**\n * flow back - Rollback migrations\n */\n\nimport { confirm, select } from '@clack/prompts'\nimport { getFlowConfig, GlobalOptions } from '../lib/config.js'\nimport { createSpinner } from '../lib/prompts.js'\nimport fs from 'fs-extra'\nimport path from 'node:path'\nimport pc from 'picocolors'\nimport { Client as PgClient } from 'pg'\nimport mysql from 'mysql2/promise'\nimport Database from 'better-sqlite3'\nimport sqlite3 from 'sqlite3'\n\nexport interface BackOptions {\n  steps?: number\n  to?: string\n  project?: string\n  yes?: boolean\n}\n\ninterface DatabaseConnection {\n  type: 'postgresql' | 'mysql' | 'sqlite'\n  client: any\n}\n\ninterface AppliedMigration {\n  id: number\n  name: string\n  checksum: string\n  applied_at: string\n}\n\nexport async function backCommand(options: BackOptions, globalOptions: GlobalOptions): Promise<void> {\n  const projectPath = options.project ? path.resolve(options.project) : process.cwd()\n  const cfg = await getFlowConfig(globalOptions, projectPath)\n  const envCfg = cfg.environments[cfg.defaultEnvironment]\n  \n  if (globalOptions.debug) {\n    console.log('Rolling back using env:', cfg.defaultEnvironment)\n  }\n  \n  const spinner = createSpinner('Connecting to database...')\n  \n  // Connect to database\n  let connection: DatabaseConnection | null = null\n  try {\n    connection = await connectToDatabase(envCfg)\n    spinner.update('Connected to database successfully')\n  } catch (error) {\n    spinner.fail('Failed to connect to database')\n    console.log(pc.red(`‚ùå Database connection failed: ${error}`))\n    return\n  }\n  \n  try {\n    // Get applied migrations\n    spinner.update('Fetching applied migrations...')\n    const appliedMigrations = await getAppliedMigrations(connection)\n    \n    if (appliedMigrations.length === 0) {\n      spinner.succeed('No migrations to rollback')\n      console.log(pc.green('‚úÖ No migrations have been applied'))\n      return\n    }\n    \n    spinner.stop()\n    \n    // Determine which migrations to rollback\n    const migrationsToRollback = await determineMigrationsToRollback(\n      appliedMigrations, \n      options, \n      envCfg,\n      projectPath\n    )\n    \n    if (migrationsToRollback.length === 0) {\n      console.log(pc.yellow('‚ö†Ô∏è  No migrations selected for rollback'))\n      return\n    }\n    \n    console.log(`\\nüìã Migrations to rollback (${migrationsToRollback.length}):`)\n    migrationsToRollback.forEach((migration, idx) => {\n      console.log(`  ${idx + 1}. ${pc.cyan(migration.name)} (applied: ${migration.applied_at})`)\n    })\n    \n    if (globalOptions.dryRun) {\n      console.log(pc.yellow('\\nüîç Dry run mode - showing what would be rolled back'))\n      for (const migration of migrationsToRollback) {\n        console.log(`\\n${pc.cyan(`--- Rollback ${migration.name} ---`)}`)\n        \n        // Try to find the DOWN migration content\n        const downContent = await findDownMigration(migration, envCfg, projectPath)\n        if (downContent) {\n          console.log(pc.gray(downContent))\n        } else {\n          console.log(pc.yellow('‚ö†Ô∏è  No rollback script found for this migration'))\n        }\n      }\n      return\n    }\n    \n    // Confirm rollback\n    const riskyMigrations = migrationsToRollback.filter(m => \n      m.name.toLowerCase().includes('drop') || \n      m.name.toLowerCase().includes('delete')\n    )\n    \n    if (riskyMigrations.length > 0) {\n      console.log(pc.red('\\n‚ö†Ô∏è  WARNING: Some migrations may contain destructive operations:'))\n      riskyMigrations.forEach(m => {\n        console.log(`  ‚Ä¢ ${pc.red(m.name)}`)\n      })\n    }\n    \n    const proceed = options.yes ? true : await confirm({\n      message: riskyMigrations.length > 0\n        ? pc.red('‚ö†Ô∏è  Are you sure you want to rollback these potentially destructive migrations?')\n        : `Rollback ${migrationsToRollback.length} migration(s)?`\n    })\n    \n    if (!proceed) {\n      console.log(pc.gray('Rollback cancelled.'))\n      return\n    }\n    \n    // Perform rollback\n    const rollbackSpinner = createSpinner('Rolling back migrations...')\n    \n    for (const migration of migrationsToRollback) {\n      try {\n        rollbackSpinner.update(`Rolling back ${migration.name}...`)\n        \n        const downContent = await findDownMigration(migration, envCfg, projectPath)\n        if (downContent) {\n          await executeMigrationRollback(connection, downContent)\n        } else {\n          console.log(pc.yellow(`‚ö†Ô∏è  No rollback script found for ${migration.name}, skipping...`))\n        }\n        \n        await removeMigrationRecord(connection, migration)\n        \n        if (globalOptions.debug) {\n          console.log(pc.green(`  ‚úÖ Rolled back ${migration.name}`))\n        }\n      } catch (error) {\n        rollbackSpinner.fail(`Failed to rollback ${migration.name}`)\n        console.log(pc.red(`‚ùå Rollback failed: ${error}`))\n        \n        // Ask if they want to continue with remaining rollbacks\n        if (migrationsToRollback.indexOf(migration) < migrationsToRollback.length - 1) {\n          const continueRollback = await confirm({\n            message: 'Continue rolling back remaining migrations?'\n          })\n          \n          if (!continueRollback) {\n            console.log(pc.yellow('‚ö†Ô∏è  Rollback process stopped'))\n            return\n          }\n        }\n      }\n    }\n    \n    rollbackSpinner.succeed('All migrations rolled back successfully')\n    console.log(pc.green('‚úÖ Migration rollback completed safely'))\n    \n  } finally {\n    // Close database connection\n    if (connection) {\n      await closeDatabaseConnection(connection)\n    }\n  }\n}\n\nasync function connectToDatabase(envCfg: any): Promise<DatabaseConnection> {\n  const connectionString = envCfg.db_connection_string || envCfg.databaseUrl;\n\n  if (!connectionString) {\n    throw new Error('Database connection string not found in flow.config.json. Please provide \"db_connection_string\" or \"databaseUrl\".')\n  }\n\n  const dbType = connectionString.split(':')[0];\n\n  switch (dbType) {\n    case 'postgresql':\n      const pgClient = new PgClient({ connectionString })\n      await pgClient.connect()\n      return { type: 'postgresql', client: pgClient }\n\n    case 'mysql':\n      const mysqlConnection = await mysql.createConnection(connectionString)\n      return { type: 'mysql', client: mysqlConnection }\n\n    case 'sqlite':\n      const sqlitePath = connectionString.substring('sqlite:'.length);\n      const sqliteDb = new sqlite3.Database(sqlitePath || './database.db')\n      return { type: 'sqlite', client: sqliteDb }\n\n    default:\n      throw new Error(`Unsupported database type: ${dbType}`)\n  }\n}\n\nasync function getAppliedMigrations(connection: DatabaseConnection): Promise<AppliedMigration[]> {\n  try {\n    const result = await executeQuery(\n      connection, \n      'SELECT id, name, checksum, applied_at FROM flow_migrations ORDER BY id DESC'\n    )\n    return result\n  } catch (error) {\n    // If the table doesn't exist, no migrations have been applied\n    return []\n  }\n}\n\nasync function determineMigrationsToRollback(\n  appliedMigrations: AppliedMigration[], \n  options: BackOptions,\n  envCfg: any,\n  projectPath: string\n): Promise<AppliedMigration[]> {\n  if (options.to) {\n    // Rollback to a specific migration (exclusive)\n    const targetIndex = appliedMigrations.findIndex(m => m.name === options.to)\n    if (targetIndex === -1) {\n      throw new Error(`Migration '${options.to}' not found in applied migrations`)\n    }\n    return appliedMigrations.slice(0, targetIndex)\n  }\n  \n  const steps = options.steps || 1\n  \n  if (steps >= appliedMigrations.length) {\n    // Confirm rolling back all migrations\n    const confirmAll = options.yes ? true : await confirm({\n      message: pc.yellow(`‚ö†Ô∏è  This will rollback ALL ${appliedMigrations.length} migrations. Continue?`)\n    })\n    \n    if (!confirmAll) {\n      return []\n    }\n    \n    return appliedMigrations\n  }\n  \n  return appliedMigrations.slice(0, steps)\n}\n\nasync function findDownMigration(migration: AppliedMigration, envCfg: any, projectPath: string): Promise<string | null> {\n  const migrationsDir = envCfg.migrationsPath || './migrations'\n  const absoluteMigrationsDir = path.resolve(projectPath, migrationsDir)\n  \n  // Find the corresponding migration file\n  const files = await fs.readdir(absoluteMigrationsDir)\n  \n  for (const filename of files) {\n    const filePath = path.join(absoluteMigrationsDir, filename)\n    const stat = await fs.stat(filePath);\n    if (stat.isDirectory()) {\n      continue;\n    }\n    \n    if (await fs.pathExists(filePath)) {\n      let content = await fs.readFile(filePath, 'utf-8')\n      \n      // Extract SQL from TypeScript/JavaScript files if needed\n      if (filename.endsWith('.ts') || filename.endsWith('.js')) {\n        content = extractDownSQLFromMigrationFile(content)\n      }\n      \n      // For .sql files, look for -- DOWN section\n      if (filename.endsWith('.sql') && content.includes('-- DOWN')) {\n        const downSection = content.split('-- DOWN')[1]\n        if (downSection) {\n          return downSection.trim()\n        }\n      }\n      \n      // If it's a dedicated down file, return the whole content\n      if (filename.includes('down') || filename.includes('_down')) {\n        return content\n      }\n    }\n  }\n  \n  return null\n}\n\nasync function executeMigrationRollback(connection: DatabaseConnection, downContent: string): Promise<void> {\n  // Split migration content by semicolon and execute each statement\n  const statements = downContent\n    .split(';')\n    .map(stmt => stmt.trim())\n    .filter(stmt => stmt.length > 0)\n  \n  for (const statement of statements) {\n    if (statement.trim()) {\n      await executeQuery(connection, statement)\n    }\n  }\n}\n\nasync function removeMigrationRecord(connection: DatabaseConnection, migration: AppliedMigration): Promise<void> {\n  const deleteQuery = (() => {\n    switch (connection.type) {\n      case 'postgresql':\n        return 'DELETE FROM flow_migrations WHERE id = $1'\n      case 'mysql':\n        return 'DELETE FROM flow_migrations WHERE id = ?'\n      case 'sqlite':\n        return 'DELETE FROM flow_migrations WHERE id = ?'\n    }\n  })()\n  \n  await executeQuery(connection, deleteQuery, [migration.id])\n}\n\nasync function executeQuery(connection: DatabaseConnection, query: string, params?: any[]): Promise<any[]> {\n  switch (connection.type) {\n    case 'postgresql':\n      const pgResult = await connection.client.query(query, params)\n      return pgResult.rows\n      \n    case 'mysql':\n      const [mysqlResult] = await connection.client.execute(query, params)\n      return Array.isArray(mysqlResult) ? mysqlResult : [mysqlResult]\n      \n    case 'sqlite':\n      return new Promise((resolve, reject) => {\n        const callback = (err: Error | null, rows: any[]) => {\n          if (err) {\n            reject(err)\n          } else {\n            resolve(rows)\n          }\n        }\n        if (query.toLowerCase().trim().startsWith('select')) {\n          connection.client.all(query, params, callback)\n        } else {\n          connection.client.run(query, params, callback)\n          resolve([]);\n        }\n      })\n      \n    default:\n      throw new Error(`Unsupported database type: ${connection.type}`)\n  }\n}\n\nasync function closeDatabaseConnection(connection: DatabaseConnection): Promise<void> {\n  switch (connection.type) {\n    case 'postgresql':\n      await connection.client.end()\n      break\n    case 'mysql':\n      await connection.client.end()\n      break\n    case 'sqlite':\n      connection.client.close()\n      break\n  }\n}\n\nfunction extractDownSQLFromMigrationFile(content: string): string {\n  // Look for down migration patterns in TypeScript/JavaScript files\n  const downPatterns = [\n    /public async down\\(.*?\\): Promise<void> \\{([\\s\\S]*?)\\}/,\n    /async down\\(.*?\\) \\{([\\s\\S]*?)\\}/,\n    /down.*?{([\\s\\S]*?)}/,\n  ]\n  \n  for (const pattern of downPatterns) {\n    const match = content.match(pattern)\n    if (match) {\n      const downCode = match[1]\n      \n      // Extract SQL from the down method\n      const sqlPatterns = [\n        /queryRunner\\.query\\s*\\(\\s*[`\"']([^`\"']+)[`\"']/g,\n        /sql\\s*`([^`]+)`/g,\n        /\"((?:DROP|ALTER|CREATE|INSERT|UPDATE|DELETE)[^\"]+)\"/gi\n      ]\n      \n      let extractedSQL = ''\n      for (const sqlPattern of sqlPatterns) {\n        let sqlMatch\n        while ((sqlMatch = sqlPattern.exec(downCode)) !== null) {\n          extractedSQL += sqlMatch[1] + ';\\n'\n        }\n      }\n      \n      return extractedSQL\n    }\n  }\n  \n  return ''\n} "],"mappings":"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","names":["log","message","createFilePath","fs","spinner","confirm","fsExtra","resolve","fs","spinner","detector","text","confirm","spinner","path","spinner","resolve","confirm","fs","path","pc","spinner","confirm","extractSQLFromMigrationFile","resolve","confirm","fs","path","pc","PgClient","mysql","sqlite3","spinner","connectToDatabase","confirm","closeDatabaseConnection","executeQuery","resolve","log"]}